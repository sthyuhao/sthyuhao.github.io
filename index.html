<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>余额不足</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="余额不足">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="余额不足">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="余额不足">
  
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">余额不足</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
      </nav>
      <nav id="sub-nav">
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-2019-03-20" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/20/2019-03-20/" class="article-date">
  <time datetime="2019-03-20T02:23:47.000Z" itemprop="datePublished">2019-03-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Category/">Category</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/20/2019-03-20/">扒一扒Category以及关联对象</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="从结构说起"><a href="#从结构说起" class="headerlink" title="从结构说起"></a>从结构说起</h2><p>源码来自<a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">objc4-750</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">category_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;   <span class="comment">//!&lt;  分类名称</span></span><br><span class="line">    <span class="keyword">classref_t</span> cls;   <span class="comment">//!&lt;  属于哪个类</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">instanceMethods</span>;</span>   <span class="comment">//!&lt;  实例方法列表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">classMethods</span>;</span>   <span class="comment">//!&lt;  类方法列表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">protocol_list_t</span> *<span class="title">protocols</span>;</span>   <span class="comment">//!&lt;  协议列表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> *<span class="title">instanceProperties</span>;</span>   <span class="comment">//!&lt;  实例属性列表</span></span><br><span class="line">    <span class="comment">// Fields below this point are not always present on disk.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> *_<span class="title">classProperties</span>;</span>   <span class="comment">//!&lt;  类属性列表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">method_list_t</span> *methodsForMeta(<span class="keyword">bool</span> isMeta) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isMeta) <span class="keyword">return</span> classMethods;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> instanceMethods;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">property_list_t</span> *propertiesForMeta(<span class="keyword">bool</span> isMeta, struct header_info *hi);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从上面的结构体，我们能发现一个分类都包含了哪些东西，从平时敲代码的经验中我们知道Category能够拓展实例方法&amp;类方法以及协议，但是Category却不能直接添加实例变量，而在结构体中却有属性列表，why？</p>
<p>带着疑问咱们从OC加载的地方开始，分析category的加载过程。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _objc_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> initialized = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (initialized) <span class="keyword">return</span>;</span><br><span class="line">    initialized = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// fixme defer initialization until an objc-using image is found?</span></span><br><span class="line">    environ_init();</span><br><span class="line">    tls_init();</span><br><span class="line">    static_init();</span><br><span class="line">    lock_init();</span><br><span class="line">    exception_init();</span><br><span class="line"></span><br><span class="line">    _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过匹配镜像文件<code>map_images</code>，我们能找到<code>_read_images</code>方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _read_images(header_info **hList, <span class="keyword">uint32_t</span> hCount, <span class="keyword">int</span> totalClasses, <span class="keyword">int</span> unoptimizedTotalClasses)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Discover categories. </span></span><br><span class="line">    <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">        <span class="keyword">category_t</span> **catlist = _getObjc2CategoryList(hi, &amp;count);</span><br><span class="line">        <span class="keyword">bool</span> hasClassProperties = hi-&gt;info()-&gt;hasCategoryClassProperties();</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="keyword">category_t</span> *cat = catlist[i];</span><br><span class="line">            <span class="comment">// 根据分类结构体中的cls查询到一个活动的类指针</span></span><br><span class="line">            Class cls = remapClass(cat-&gt;cls);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!cls) &#123;</span><br><span class="line">                <span class="comment">// Category's target class is missing (probably weak-linked).</span></span><br><span class="line">                <span class="comment">// Disavow any knowledge of this category.</span></span><br><span class="line">                catlist[i] = nil;</span><br><span class="line">                <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(<span class="string">"CLASS: IGNORING category \?\?\?(%s) %p with "</span></span><br><span class="line">                                 <span class="string">"missing weak-linked target class"</span>, </span><br><span class="line">                                 cat-&gt;name, cat);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Process this category. </span></span><br><span class="line">            <span class="comment">// First, register the category with its target class. </span></span><br><span class="line">            <span class="comment">// Then, rebuild the class's method lists (etc) if </span></span><br><span class="line">            <span class="comment">// the class is realized.</span></span><br><span class="line">             <span class="comment">//  首先，为目标类注册category，然后对已实现的类重新构造类方法列表</span></span><br><span class="line">            <span class="keyword">bool</span> classExists = NO;</span><br><span class="line">            <span class="comment">//  如果category存在实例方法/协议/属性</span></span><br><span class="line">            <span class="keyword">if</span> (cat-&gt;instanceMethods ||  cat-&gt;protocols  ||  cat-&gt;instanceProperties) &#123;</span><br><span class="line">                <span class="comment">//  添加未附加的分类</span></span><br><span class="line">                addUnattachedCategoryForClass(cat, cls, hi);</span><br><span class="line">                <span class="keyword">if</span> (cls-&gt;isRealized()) &#123;</span><br><span class="line">                    remethodizeClass(cls);</span><br><span class="line">                    classExists = YES;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(<span class="string">"CLASS: found category -%s(%s) %s"</span>, </span><br><span class="line">                                 cls-&gt;nameForLogging(), cat-&gt;name, </span><br><span class="line">                                 classExists ? <span class="string">"on existing class"</span> : <span class="string">""</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cat-&gt;classMethods  ||  cat-&gt;protocols  ||  (hasClassProperties &amp;&amp; cat-&gt;_classProperties)) &#123;</span><br><span class="line">                addUnattachedCategoryForClass(cat, cls-&gt;ISA(), hi);</span><br><span class="line">                <span class="keyword">if</span> (cls-&gt;ISA()-&gt;isRealized()) &#123;</span><br><span class="line">                    remethodizeClass(cls-&gt;ISA());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(<span class="string">"CLASS: found category +%s(%s)"</span>, </span><br><span class="line">                                 cls-&gt;nameForLogging(), cat-&gt;name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>_read_images()</code>调用了<code>remethodizeClass()</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* remethodizeClass</span></span><br><span class="line"><span class="comment">* Attach outstanding categories to an existing class.</span></span><br><span class="line"><span class="comment">* 将外部的categories添加到已存在的类上</span></span><br><span class="line"><span class="comment">* Fixes up cls's method list, protocol list, and property list.</span></span><br><span class="line"><span class="comment">* 修正类的方法列表、协议列表、属性列表</span></span><br><span class="line"><span class="comment">* Updates method caches for cls and its subclasses.</span></span><br><span class="line"><span class="comment">* 更新类和子类的方法缓存</span></span><br><span class="line"><span class="comment">* Locking: runtimeLock must be held by the caller</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">remethodizeClass</span><span class="params">(Class cls)</span> </span>&#123;</span><br><span class="line">    category_list *cats;</span><br><span class="line">    <span class="keyword">bool</span> isMeta;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    isMeta = cls-&gt;isMetaClass();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Re-methodizing: check for more categories</span></span><br><span class="line">    <span class="keyword">if</span> ((cats = unattachedCategoriesForClass(cls, <span class="literal">false</span><span class="comment">/*not realizing*/</span>))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"CLASS: attaching categories to class '%s' %s"</span>, </span><br><span class="line">                         cls-&gt;nameForLogging(), isMeta ? <span class="string">"(meta)"</span> : <span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        attachCategories(cls, cats, <span class="literal">true</span> <span class="comment">/*flush caches*/</span>);        </span><br><span class="line">        <span class="built_in">free</span>(cats);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>attachCategories()</code>就是如何将category的方法、协议、属性写入类的函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  将分类中的方法列表、属性列表、协议列表添加到类中</span></span><br><span class="line"><span class="comment">//  假设cats中的分类都是按加载顺序排列的，最早加载的将第一个被添加</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> </span><br><span class="line">attachCategories(Class cls, category_list *cats, <span class="keyword">bool</span> flush_caches) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!cats) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (PrintReplacedMethods) printReplacements(cls, cats);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> isMeta = cls-&gt;isMetaClass();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fixme rearrange to remove these intermediate allocations</span></span><br><span class="line">    <span class="keyword">method_list_t</span> **mlists = (<span class="keyword">method_list_t</span> **)</span><br><span class="line">        <span class="built_in">malloc</span>(cats-&gt;count * <span class="keyword">sizeof</span>(*mlists));</span><br><span class="line">    <span class="keyword">property_list_t</span> **proplists = (<span class="keyword">property_list_t</span> **)</span><br><span class="line">        <span class="built_in">malloc</span>(cats-&gt;count * <span class="keyword">sizeof</span>(*proplists));</span><br><span class="line">    <span class="keyword">protocol_list_t</span> **protolists = (<span class="keyword">protocol_list_t</span> **)</span><br><span class="line">        <span class="built_in">malloc</span>(cats-&gt;count * <span class="keyword">sizeof</span>(*protolists));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Count backwards through cats to get newest categories first</span></span><br><span class="line">    <span class="keyword">int</span> mcount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> propcount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> protocount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = cats-&gt;count;</span><br><span class="line">    <span class="keyword">bool</span> fromBundle = NO;</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; entry = cats-&gt;<span class="built_in">list</span>[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">method_list_t</span> *mlist = entry.cat-&gt;methodsForMeta(isMeta);</span><br><span class="line">        <span class="keyword">if</span> (mlist) &#123;</span><br><span class="line">            mlists[mcount++] = mlist;</span><br><span class="line">            fromBundle |= entry.hi-&gt;isBundle();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">property_list_t</span> *proplist = </span><br><span class="line">            entry.cat-&gt;propertiesForMeta(isMeta, entry.hi);</span><br><span class="line">        <span class="keyword">if</span> (proplist) &#123;</span><br><span class="line">            proplists[propcount++] = proplist;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protocol_list_t</span> *protolist = entry.cat-&gt;protocols;</span><br><span class="line">        <span class="keyword">if</span> (protolist) &#123;</span><br><span class="line">            protolists[protocount++] = protolist;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> rw = cls-&gt;data();</span><br><span class="line"></span><br><span class="line">    prepareMethodLists(cls, mlists, mcount, NO, fromBundle);</span><br><span class="line">    rw-&gt;methods.attachLists(mlists, mcount);</span><br><span class="line">    <span class="built_in">free</span>(mlists);</span><br><span class="line">    <span class="keyword">if</span> (flush_caches  &amp;&amp;  mcount &gt; <span class="number">0</span>) flushCaches(cls);</span><br><span class="line"></span><br><span class="line">    rw-&gt;properties.attachLists(proplists, propcount);</span><br><span class="line">    <span class="built_in">free</span>(proplists);</span><br><span class="line"></span><br><span class="line">    rw-&gt;protocols.attachLists(protolists, protocount);</span><br><span class="line">    <span class="built_in">free</span>(protolists);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码就是一个category的加载过程</p>
<p>从上面的函数中我们可以看到一个新的结构体<code>class_rw_t</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_rw_t</span> &#123;</span></span><br><span class="line">    <span class="comment">// Be warned that Symbolication knows the layout of this structure.</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="keyword">uint32_t</span> version;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">class_ro_t</span> *ro;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">method_array_t</span> methods;</span><br><span class="line">    <span class="keyword">property_array_t</span> properties;</span><br><span class="line">    <span class="keyword">protocol_array_t</span> protocols;</span><br><span class="line"></span><br><span class="line">    Class firstSubclass;</span><br><span class="line">    Class nextSiblingClass;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *demangledName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个结构体中我们可以看见他有方法列表、属性列表、协议列表，我们都知道<code>@property=ivar+getter()+setter()</code>，虽然有属性列表，但实际上没有实例变量这个属性就并没有什么卵用了。</p>
<p><code>class_rw_t</code>中有一个叫做<code>class_ro_t</code>的结构体</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_ro_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="keyword">uint32_t</span> instanceStart;</span><br><span class="line">    <span class="keyword">uint32_t</span> instanceSize;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></span><br><span class="line">    <span class="keyword">uint32_t</span> reserved;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> * ivarLayout;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * name;</span><br><span class="line">    <span class="keyword">method_list_t</span> * baseMethodList; <span class="comment">// 方法列表</span></span><br><span class="line">    <span class="keyword">protocol_list_t</span> * baseProtocols; <span class="comment">// 协议列表</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">ivar_list_t</span> * ivars; <span class="comment">// 实例变量列表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> * weakIvarLayout;</span><br><span class="line">    <span class="keyword">property_list_t</span> *baseProperties; <span class="comment">// 属性列表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">method_list_t</span> *baseMethods() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> baseMethodList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个结构体中的成员要比<code>class_rw_t</code>的多一些，而且有咱们想要<code>ivars</code>，那为什么<code>category</code>不能直接往<code>class_ro_t</code>中写入实例变量呢?</p>
<p>从名字上我们可以猜测<code>ro</code>为<code>readonly</code>，<code>rw</code>则是<code>readwrite</code>，这就是不能往<code>class_ro_t</code>写入的原因之一，其二<code>class_ro_t</code>存放的是编译期间就确定的，内存已经不可更改，而<code>category</code>咱们都知道是在运行时决议的，当镜像加载的时候，<code>methodizeClass</code>方法会将 <code>baseMethodList</code> 添加到<code>class_rw_t</code>的<code>methods</code>列表中，之后会遍历<code>category_list</code>，并将<code>category</code>的方法也添加到<code>methods</code>列表中。</p>
<h2 id="一定要给Category添加实例变量怎么办？"><a href="#一定要给Category添加实例变量怎么办？" class="headerlink" title="一定要给Category添加实例变量怎么办？"></a>一定要给Category添加实例变量怎么办？</h2><p>runtime有个玩意叫做关联对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">OBJC_EXPORT <span class="keyword">void</span></span><br><span class="line">objc_setAssociatedObject(id _Nonnull object, <span class="keyword">const</span> <span class="keyword">void</span> * _Nonnull key,</span><br><span class="line">                         id _Nullable value, objc_AssociationPolicy policy)</span><br><span class="line">                         </span><br><span class="line">OBJC_EXPORT id _Nullable</span><br><span class="line">objc_getAssociatedObject(id _Nonnull object, <span class="keyword">const</span> <span class="keyword">void</span> * _Nonnull key)</span><br><span class="line"></span><br><span class="line">OBJC_EXPORT <span class="keyword">void</span></span><br><span class="line">objc_removeAssociatedObjects(id _Nonnull object)</span><br></pre></td></tr></table></figure>
<p>通过以上三个函数即可给<code>Category</code>添加上实例变量。</p>
<p>先分析<code>objc_setAssociatedObject()</code>,该函数会调用<code>_object_set_associative_reference()</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _object_set_associative_reference(id object, <span class="keyword">void</span> *key, id value, <span class="keyword">uintptr_t</span> policy) &#123;</span><br><span class="line">    <span class="comment">// retain the new value (if any) outside the lock.</span></span><br><span class="line">    <span class="function">ObjcAssociation <span class="title">old_association</span><span class="params">(<span class="number">0</span>, nil)</span></span>;</span><br><span class="line">    <span class="comment">//  锁外对新值进行持有操作</span></span><br><span class="line">    <span class="comment">//  如果新值存在，传入值以及持有策略</span></span><br><span class="line">    id new_value = value ? acquireValue(value, policy) : nil;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//  获取AssociationsHashMap</span></span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        <span class="function">AssociationsHashMap &amp;<span class="title">associations</span><span class="params">(manager.associations())</span></span>;</span><br><span class="line">        <span class="comment">//  对对象进行伪装，disguised_object作为ObjectAssociationMap的key</span></span><br><span class="line">        <span class="keyword">disguised_ptr_t</span> disguised_object = DISGUISE(object);</span><br><span class="line">        <span class="keyword">if</span> (new_value) &#123;</span><br><span class="line">            <span class="comment">//  根据伪装对象寻找ObjectAssociationMap</span></span><br><span class="line">            AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">            <span class="keyword">if</span> (i != associations.end()) &#123;  <span class="comment">//  判断之前是否存在关联对象</span></span><br><span class="line">                <span class="comment">// secondary table exists</span></span><br><span class="line">                ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">                <span class="comment">//  根据key寻找ObjectAssociationMap中的ObjcAssociation</span></span><br><span class="line">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">                <span class="keyword">if</span> (j != refs-&gt;end()) &#123;</span><br><span class="line">                    <span class="comment">//  如果之前存在ObjcAssociation，将旧值存入old_association，新值存入ObjcAssociation</span></span><br><span class="line">                    old_association = j-&gt;second;</span><br><span class="line">                    j-&gt;second = ObjcAssociation(policy, new_value);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//  如果之前不存在ObjcAssociation，创建新的ObjcAssociation，并将新值存入</span></span><br><span class="line">                    (*refs)[key] = ObjcAssociation(policy, new_value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//  不存在关联对象则新建ObjectAssociationMap</span></span><br><span class="line">                ObjectAssociationMap *refs = <span class="keyword">new</span> ObjectAssociationMap;</span><br><span class="line">                associations[disguised_object] = refs;</span><br><span class="line">                <span class="comment">//  将新的 [伪装对象地址 : ObjectAssociationMap] 存入AssociationsHashMap</span></span><br><span class="line">                (*refs)[key] = ObjcAssociation(policy, new_value);</span><br><span class="line">                object-&gt;setHasAssociatedObjects();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//  如果新值为nil，判断之前是否存在关联对象，存在则清除，不存在则不做任何操作</span></span><br><span class="line">            <span class="comment">// setting the association to nil breaks the association.</span></span><br><span class="line">            AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">            <span class="keyword">if</span> (i !=  associations.end()) &#123;</span><br><span class="line">                ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">                <span class="keyword">if</span> (j != refs-&gt;end()) &#123;</span><br><span class="line">                    old_association = j-&gt;second;</span><br><span class="line">                    refs-&gt;erase(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// release the old value (outside of the lock).</span></span><br><span class="line">    <span class="comment">//  在锁外对旧值进行release操作</span></span><br><span class="line">    <span class="keyword">if</span> (old_association.hasValue()) ReleaseValue()(old_association);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上述代码中，我们可以得知关联对象并没有存在相关的类当中。<br>敲黑板了！该函数中出现了四个类，分别是<code>AssociationsManager</code>, <code>AssociationsHashMap</code>, <code>ObjectAssociationMap</code>,<code>ObjcAssociation</code>。</p>
<p><code>ObjcAssociation</code> 存有实例变量的值&amp;实例变量的持有策略。<br><code>ObjectAssociationMap</code> 是以实例变量的名称为key，<code>ObjcAssociation</code>为value的哈希表<br><code>AssociationsHashMap</code> 是以<code>disguised_ptr_t</code>即类的伪装对象地址为key，<code>ObjectAssociationMap</code>为value的哈希表</p>
<p>关联对象统一由<code>AssociationsManager</code>来管理，<code>AssociationsManager</code>维护了一张<code>AssociationsHashMap</code>，在<code>AssociationsHashMap</code>中有若干个<code>ObjectAssociationMap</code></p>
<p>有赋值就会有取值，但这里咱们就不过多的去分析了，感兴趣的同学可以自行查阅源码，与赋值过程的原理基本上一致。</p>
<p>到这里又引发了一个疑问，关联对象是什么时候被清除的？<br>在之前的文章中有介绍对象<code>dealloc</code>的过程</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">objc_object::rootDealloc()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span>;  <span class="comment">// fixme necessary?</span></span><br><span class="line">    <span class="keyword">if</span> (fastpath(isa.nonpointer  &amp;&amp;  </span><br><span class="line">                 !isa.weakly_referenced  &amp;&amp;  </span><br><span class="line">                 !isa.has_assoc  &amp;&amp;  </span><br><span class="line">                 !isa.has_cxx_dtor  &amp;&amp;  </span><br><span class="line">                 !isa.has_sidetable_rc))</span><br><span class="line">    &#123;</span><br><span class="line">        assert(!sidetable_present());</span><br><span class="line">        <span class="built_in">free</span>(<span class="keyword">this</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        object_dispose((id)<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果当前对象存在关联对象的时候，则会触发<code>object_dispose()</code>，然后调用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">objc_destructInstance</span><span class="params">(id obj)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        <span class="comment">// Read all of the flags at once for performance.</span></span><br><span class="line">        <span class="keyword">bool</span> cxx = obj-&gt;hasCxxDtor();</span><br><span class="line">        <span class="keyword">bool</span> assoc = obj-&gt;hasAssociatedObjects();</span><br><span class="line">        <span class="comment">// This order is important.</span></span><br><span class="line">        <span class="keyword">if</span> (cxx) object_cxxDestruct(obj);</span><br><span class="line">        <span class="keyword">if</span> (assoc) _object_remove_assocations(obj);</span><br><span class="line">        obj-&gt;clearDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果存在关联对象就会调用<code>_object_remove_assocations</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _object_remove_assocations(id object) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt; ObjcAssociation,ObjcAllocator&lt;ObjcAssociation&gt; &gt; elements;</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        <span class="function">AssociationsHashMap &amp;<span class="title">associations</span><span class="params">(manager.associations())</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (associations.size() == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">disguised_ptr_t</span> disguised_object = DISGUISE(object);</span><br><span class="line">        AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">        <span class="keyword">if</span> (i != associations.end()) &#123;</span><br><span class="line">            <span class="comment">// copy all of the associations that need to be removed.</span></span><br><span class="line">            ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">            <span class="keyword">for</span> (ObjectAssociationMap::iterator j = refs-&gt;begin(), end = refs-&gt;end(); j != end; ++j) &#123;</span><br><span class="line">                elements.push_back(j-&gt;second);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// remove the secondary table.</span></span><br><span class="line">            <span class="keyword">delete</span> refs;</span><br><span class="line">            associations.erase(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// the calls to releaseValue() happen outside of the lock.</span></span><br><span class="line">    for_each(elements.begin(), elements.end(), ReleaseValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码也就不加注释啦，大致的流程就是：<br>1、通过AssociationsManager获取AssociationsHashMap<br>2、通过伪装对象得到disguised_ptr_t<br>3、根据disguised_ptr_t取得对应的ObjectAssociationMap<br>4、遍历ObjectAssociationMap取出ObjcAssociation，然后推进elements<br>5、清除AssociationsManager中的数据<br>6、最后遍历elements，释放数据</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/20/2019-03-20/" data-id="cju0vz2x1000uo4umgsxu4qcf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Category/">Category</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2019-02-13" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/13/2019-02-13/" class="article-date">
  <time datetime="2019-02-13T11:23:10.000Z" itemprop="datePublished">2019-02-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/随笔杂谈/">随笔杂谈</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/13/2019-02-13/">年初的一些感慨</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>不知不觉2018和2019已完成了交接，戊戌年也许是比较惨淡的一年吧，年中老外公的离开已让我唏嘘不已，年尾又收到了被裁的通知，早早的提前过年了，有的人悲伤有的人欢喜，当时还闹的不可开交，但过去了也就那么一回事，有的同事脑子不清醒，向竞品公司泄漏公司数据，反倒被一纸装书送上了法庭。唉，不提也罢！</p>
<p>年底休息了大概一礼拜，开始了寻找工作的旅程，戊戌年资本市场的不堪导致了各个公司都停止招聘甚至裁员，从最开始的二维火降薪20%开始，到阿里收缩HC，然后卖好车CEO发了一封全员信便开始了裁员，很不幸，我在名单里，刚被拓爷喊去的那一瞬间我知道就要离开这家呆了近三年的公司了，拓爷说何必为了那点钱而背上被裁的名声，背负着一屁股的债，有时真是身不由己，若能幸福安稳，谁又愿颠沛流离呢？后来同万剑谈妥了，大家都让了一步，毕竟杭州互联网就这么大的圈子，抬头不见低头见的，闹僵了多拿那些钱又有何意义？虽说钱是身外之物，但，没了钱我连怎么在杭州立足都不知。</p>
<p>初八，入职了海拍客，熟悉的gitlab，熟悉的confluence，熟悉的cocoapods，熟悉的组件化项目，看起来一切都是那么的熟悉，只是身边的物与人都不是在曾经熟悉的他们。一封邮件将我惊醒，这不是老同事沙皮么？原来他也在这，还有悠然，回首一看，圈子还真小，哪都能遇见熟人。草草的聊了几句猛然发现自己什么时候变得如此的多愁善感，又或是本来就是这样？想着父亲都已花白了头发，而自己却不能陪在他身旁。他总说让他快些抱上孙子，母亲也总是跟我诉说你老爸又喝了多少多少酒，脑子都被酒精给烧坏了。有些时候真是身不由己，唉！</p>
<p>2019了，还要继续跟2018一样霍霍过去么？也是要到而立之年的人了，贪玩的毛病也不知何时才可改变。在这立个Target先吧，夯实基础，往音视频方向走一走，不求一鸣惊人，只求多一项技能护体。每年去灵隐寺拜拜药师佛，为父母家人求个平安健康！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/02/13/2019-02-13/" data-id="cju0vz2vx0004o4um10h6bwec" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/随笔杂谈/">随笔杂谈</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2018-12-21" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/21/2018-12-21/" class="article-date">
  <time datetime="2018-12-21T03:30:10.000Z" itemprop="datePublished">2018-12-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/混淆/">混淆</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/21/2018-12-21/">集成Hikari问题汇总</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>此文记录了编译Hikari混淆器所遇到的问题，希望对有同样问题的你有些帮助，也写给未来遇到问题的自己。</p>
<h2 id="lldb-codesign-no-identity-found"><a href="#lldb-codesign-no-identity-found" class="headerlink" title="lldb_codesign no identity found"></a>lldb_codesign no identity found</h2><p>准备在项目中引入Hikari混淆器，Xcode9编译成功后并且能正常运行，但最近苹果修复了Xcode10打包iOS9Crash的问题后我也就把macOS升级到了mojave，Xcode也升级到了10，问题也就来了，之前的Hikari ToolChain也没法用了，怎么办？重装呗！</p>
<p>重新执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b release_70 --recursive https://github.com/HikariObfuscator/Hikari.git Hikari &amp;&amp; mkdir Build &amp;&amp; cd Build &amp;&amp; cmake -G &quot;Ninja&quot; -DCMAKE_BUILD_TYPE=MinSizeRel -DLLVM_APPEND_VC_REV=on -DLLVM_CREATE_XCODE_TOOLCHAIN=on -DCMAKE_INSTALL_PREFIX=~/Library/Developer/ ../Hikari &amp;&amp; ninja &amp;&amp;ninja install-xcode-toolchain &amp;&amp; git clone https://github.com/HikariObfuscator/Resources.git ~/Hikari &amp;&amp; rsync -a --ignore-existing /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/ ~/Library/Developer/Toolchains/Hikari.xctoolchain/ &amp;&amp; rm ~/Library/Developer/Toolchains/Hikari.xctoolchain/ToolchainInfo.plist</span><br></pre></td></tr></table></figure>
<p>困扰了我两天的问题来了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[4399/4695] Linking CXX executable bin/debugserver</span><br><span class="line">FAILED: bin/debugserver</span><br><span class="line">: &amp;&amp; /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/c++  -fPIC -fvisibility-inlines-hidden -Werror=date-time -Werror=unguarded-availability-new -std=c++11 -Wall -Wextra -Wno-unused-parameter -Wwrite-strings -Wcast-qual -Wmissing-field-initializers -pedantic -Wno-long-long -Wcovered-switch-default -Wnon-virtual-dtor -Wdelete-non-virtual-dtor -Wstring-conversion -fdiagnostics-color -Wno-deprecated-declarations -Wno-unknown-pragmas -Wno-strict-aliasing -Wno-deprecated-register -Wno-vla-extension -Wno-gnu-zero-variadic-macro-arguments -Wno-zero-length-array -Wno-extended-offsetof -Os -DNDEBUG -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.14.sdk -Wl,-search_paths_first -Wl,-headerpad_max_install_names -stdlib=libc++ -Wl,-sectcreate,__TEXT,__info_plist,/Users/yuhao/HikariObfuscator/Hikari/tools/lldb/tools/debugserver/source/../resources/lldb-debugserver-Info.plist    -Wl,-dead_strip tools/lldb/tools/debugserver/source/CMakeFiles/debugserver.dir/debugserver.cpp.o  -o bin/debugserver  -Wl,-rpath,@loader_path/../lib lib/liblldbDebugserverCommon.a -framework Cocoa -framework CoreFoundation -framework Foundation lib/liblldbDebugserverArchSupport.a lib/liblldbDebugserverDarwin_DarwinLog.a -lcompression &amp;&amp; cd /Users/yuhao/HikariObfuscator/Build/bin &amp;&amp; /usr/local/Cellar/cmake/3.13.2/bin/cmake -E env CODESIGN_ALLOCATE=/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/codesign_allocate codesign --force --sign lldb_codesign --entitlements /Users/yuhao/HikariObfuscator/Hikari/tools/lldb/tools/debugserver/source/../../../resources/debugserver-macosx-entitlements.plist /Users/yuhao/HikariObfuscator/Build/bin/debugserver</span><br><span class="line">lldb_codesign: no identity found</span><br></pre></td></tr></table></figure>
<p>最初碰到问题时觉得是执行debugserver出问题了，也没有仔细查看问题就直接去google了，然而看了一遍遍的文章，一篇篇别的LLVM项目的issue也能解决问题。后来觉得会不会是debugserver在mojave和Xcode10上是不是有什么问题？然后找到了一个<a href="https://github.com/derekparker/delve/issues/1398" target="_blank" rel="noopener">issue</a>，这里表示需要安装完整的Xcode command line tools，随后执行了<code>xcode-select --install</code>，执行完再次编译Hikari，依然出现同样的错误。</p>
<p>看看Hikari的issue吧，也许会遇到同样错误的同学，果不其然<a href="https://github.com/HikariObfuscator/Hikari/issues/24" target="_blank" rel="noopener">Linking CXX executable bin/debugserver failed</a>。<br>这个issue也同样遇到了<code>Linking CXX executable bin/debugserver
FAILED</code>的问题，但看了下内容，好像并不一样，zhang总的回答是<code>Just remove lldb from tools/lldb, it&#39;s too much troublesome to setup on macOS</code>，于是跟着照做，再次编译。WTF，两小时过去后依然卡在同一个位置。</p>
<h2 id="找到问题的根本原因"><a href="#找到问题的根本原因" class="headerlink" title="找到问题的根本原因"></a>找到问题的根本原因</h2><p>仔细分析错误日志，日志的最后提到了<code>lldb_codesign: no identity found</code>，再次google，搜到的回答有说需要check一下<code>lldb_codesign</code>的<code>certificate</code>，我也是哔了狗了，最终的解决方案就是添加一个<code>lldb_codesign</code>证书，信任就行了，具体执行请参照<a href="https://opensource.apple.com/source/lldb/lldb-69/docs/code-signing.txt" target="_blank" rel="noopener">这里</a>。</p>
<p>到这，Hikari编译加配置是成功了，更换了Xcode的ToolChain，build一哈，一个新的问题又来了<br><code>clang: error: cannot specify -o when generating multiple output files</code><br><img src="https://raw.githubusercontent.com/sthyuhao/BlogImgZone/master/77d0b794a9a38339c7d9eff92e990e.jpg" alt><br>如上图所示，将图中的配置项置成NO即可，再次Build，Perfect！</p>
<h2 id="Undefined-symbols-isOSVersionAtLeast"><a href="#Undefined-symbols-isOSVersionAtLeast" class="headerlink" title="Undefined symbols ___isOSVersionAtLeast"></a>Undefined symbols ___isOSVersionAtLeast</h2><p>上面的配置让我们在demo中可以完美编译，但是拉到我们的项目中又出了个<a href="https://github.com/HikariObfuscator/Hikari/issues/56" target="_blank" rel="noopener">幺蛾子</a>，zhang总在issue中的回答是需要显示的链接<code>clang-rt</code>,从<code>Hikari.xctoolchain/usr/lib/clang/10.0.0/lib/darwin</code>找到<code>libclang_rt.ios.a</code>，简单粗暴的办法就是直接拖进主工程，并且在<code>Build Phases</code>选项卡下的<code>Link Binary With Libraries</code>下引入<code>libclang_rt.ios.a</code>。</p>
<h2 id="Pods库不能使用？"><a href="#Pods库不能使用？" class="headerlink" title="Pods库不能使用？"></a>Pods库不能使用？</h2><p>由于我们的项目使用了Pods管理组件模块，仅仅在主工程配置build Settings并不能影响到Pods中的代码，如果直接在Pods的proj文件中修改只会在本地文件生效，而别人拉下来重新pod install之后配置项又变成了空的。</p>
<h3 id="怎么解决？"><a href="#怎么解决？" class="headerlink" title="怎么解决？"></a>怎么解决？</h3><p>目前有两种方案，一种是在podfile写<code>post_install</code>脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">post_install do |installer|</span><br><span class="line">    installer.pods_project.targets.each do |target|</span><br><span class="line">        target.build_configurations.each do |config|</span><br><span class="line">            if target.name == &apos;target名称&apos; #对指定的库进行混淆</span><br><span class="line">                config.build_settings[&apos;OTHER_CFLAGS&apos;] = &apos;-mllvm -enable-allobf&apos;</span><br><span class="line">            end</span><br><span class="line">            config.build_settings[&apos;COMPILER_INDEX_STORE_ENABLE&apos;] = &apos;NO&apos;</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>这种方案比较灵活，指哪打哪。</p>
<p>另一种方案，在<code>podsepc</code>文件中修改配置项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s.pod_target_xcconfig = &#123;</span><br><span class="line">    &apos;OTHER_CFLAGS&apos; =&gt; &apos;-mllvm -enable-allobf&apos;,</span><br><span class="line">    &apos;COMPILER_INDEX_STORE_ENABLE&apos; =&gt; &apos;NO&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方案稍显笨重，如果需要修改还需要对库重新打包。<br>如果有需要推荐第一种方案。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/21/2018-12-21/" data-id="cju0vz2vr0001o4umv15tf9dj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LLVM/">LLVM</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2018-11-12" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/12/2018-11-12/" class="article-date">
  <time datetime="2018-11-12T11:41:50.000Z" itemprop="datePublished">2018-11-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/block/">block</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/12/2018-11-12/">解析__block</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="block在什么情况下使用？"><a href="#block在什么情况下使用？" class="headerlink" title="__block在什么情况下使用？"></a>__block在什么情况下使用？</h2><p>前一篇文章中我们知道了block拥有捕获变量的能力，但是block却不能改变自动变量的值，每当我们尝试着在block中修改某个自动变量的时候编译器都会抛出一个错误<code>Variable is not assignable (missing __block type specifier)</code>,表示该变量在block中不可被赋值，需要使用__block修饰。但是当我们尝试在block中去修改全局变量、静态变量、全局静态变量却是可以通过的，这是为什么？</p>
<p>block捕获到的自动变量只是该变量的值，而全局变量、静态变量、全局静态变量的值为什么能修改？<br>全局变量和静态全局变量是存储在内存全局区，因为作用域的原因使得他们可以在block中被修改。<br>静态变量被block捕获的是内存地址的值，所以也能被修改。</p>
<h2 id="block修饰符都做了些啥？"><a href="#block修饰符都做了些啥？" class="headerlink" title="__block修饰符都做了些啥？"></a>__block修饰符都做了些啥？</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        __block <span class="keyword">int</span> val = <span class="number">1</span>;</span><br><span class="line">        __block NSString *str = [NSString <span class="built_in">string</span>];</span><br><span class="line">        NSLog(@<span class="string">"val初始化地址-%p"</span>, &amp;val);</span><br><span class="line">        NSLog(@<span class="string">"str初始化地址-%p"</span>, &amp;str);</span><br><span class="line">        <span class="keyword">void</span> (^aBlock)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">            val++;</span><br><span class="line">            str = @<span class="string">"a"</span>;</span><br><span class="line">            NSLog(@<span class="string">"val block地址-%p"</span>, &amp;val);</span><br><span class="line">            NSLog(@<span class="string">"str block地址-%p"</span>, &amp;str);</span><br><span class="line">        &#125;;</span><br><span class="line">        NSLog(@<span class="string">"%@"</span>, aBlock);</span><br><span class="line">        aBlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>老套路，<code>clang -rewrite-objc maim.m</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">Block_byref_val_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> *__isa;</span><br><span class="line">__Block_byref_val_0 *__forwarding;</span><br><span class="line"> <span class="keyword">int</span> __flags;</span><br><span class="line"> <span class="keyword">int</span> __size;</span><br><span class="line"> <span class="keyword">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">Block_byref_str_1</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> *__isa;</span><br><span class="line">__Block_byref_str_1 *__forwarding;</span><br><span class="line"> <span class="keyword">int</span> __flags;</span><br><span class="line"> <span class="keyword">int</span> __size;</span><br><span class="line"> <span class="keyword">void</span> (*__Block_byref_id_object_copy)(<span class="keyword">void</span>*, <span class="keyword">void</span>*);</span><br><span class="line"> <span class="keyword">void</span> (*__Block_byref_id_object_dispose)(<span class="keyword">void</span>*);</span><br><span class="line"> NSString *str;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>头部先是建了两个结构体，分别是基础数据类型和对象数据类型，基础数据类型结构体有五个成员：<br>1、isa指针<br>2、指向自身类型的指针<br>3、标记flag<br>4、占用内存大小<br>5、变量的值<br>而对象数据类型则多出了<code>__Block_byref_id_object_copy()</code>和<code>__Block_byref_id_object_dispose()</code>,从字面上看着两个函数大概是用于内存管理的。</p>
<p>附上重写后的完整代码，一步一步来分析</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  __Block_byref_str_1 *str; <span class="comment">// by ref</span></span><br><span class="line">  __Block_byref_val_0 *val; <span class="comment">// by ref</span></span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, __Block_byref_str_1 *_str, __Block_byref_val_0 *_val, <span class="keyword">int</span> flags=<span class="number">0</span>) : str(_str-&gt;__forwarding), val(_val-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">    __Block_byref_val_0 *val = __cself-&gt;val; <span class="comment">// bound by ref</span></span><br><span class="line">    __Block_byref_str_1 *str = __cself-&gt;str; <span class="comment">// bound by ref</span></span><br><span class="line"></span><br><span class="line">    (val-&gt;__forwarding-&gt;val)++;</span><br><span class="line">    (str-&gt;__forwarding-&gt;str) = (NSString *)&amp;__NSConstantStringImpl__var_folders_tr_t3h53q856n11q1hrk0gc6bgm0000gn_T_main_00d5a1_mi_2;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;</span><br><span class="line">    _Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;str, (<span class="keyword">void</span>*)src-&gt;str, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);</span><br><span class="line">    _Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;val, (<span class="keyword">void</span>*)src-&gt;val, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_dispose_0(struct __main_block_impl_0*src) &#123;</span><br><span class="line">    _Block_object_dispose((<span class="keyword">void</span>*)src-&gt;str, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);</span><br><span class="line">    _Block_object_dispose((<span class="keyword">void</span>*)src-&gt;val, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">  <span class="keyword">void</span> (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</span><br><span class="line">  <span class="keyword">void</span> (*dispose)(struct __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool;</span><br><span class="line">        <span class="comment">//  初始化val</span></span><br><span class="line">        __attribute__((__blocks__(byref))) __Block_byref_val_0 val = &#123;(<span class="keyword">void</span>*)<span class="number">0</span>,(__Block_byref_val_0 *)&amp;val, <span class="number">0</span>, <span class="keyword">sizeof</span>(__Block_byref_val_0), <span class="number">1</span>&#125;;</span><br><span class="line">        __attribute__((__blocks__(byref))) __Block_byref_str_1 str = &#123;(<span class="keyword">void</span>*)<span class="number">0</span>,(__Block_byref_str_1 *)&amp;str, <span class="number">33554432</span>, <span class="keyword">sizeof</span>(__Block_byref_str_1), __Block_byref_id_object_copy_131, __Block_byref_id_object_dispose_131, ((NSString * _Nonnull (*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)objc_getClass(<span class="string">"NSString"</span>), sel_registerName(<span class="string">"string"</span>))&#125;;</span><br><span class="line">        <span class="keyword">void</span> (*aBlock)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_str_1 *)&amp;str, (__Block_byref_val_0 *)&amp;val, <span class="number">570425344</span>));</span><br><span class="line">        ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)aBlock)-&gt;FuncPtr)((__block_impl *)aBlock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看见block的构造函数中isa是个_NSConcreteStackBlock，但是在__main_block_desc_0()中出现了(<em> copy) 和(</em> dispose)，这两个函数会将block推入堆中以及释放block（详情可查阅<a href="https://sthyuhao.github.io/2018/11/01/2018-10-31/" target="_blank" rel="noopener">从源码分析Block的内存管理</a>）。</p>
<p>从main函数开始，先是初始化了val变量，注意观察第二个成员也就是<code>__forwarding</code>,他好像指向了val自己？带着这个疑问咱们继续往下走,NSLog直接忽略，在block构造的时候有个参数是<code>fp</code>也就是<code>__main_block_func_0</code>,这个参数就是block内部回调方法的实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">    __Block_byref_val_0 *val = __cself-&gt;val; <span class="comment">// bound by ref</span></span><br><span class="line">    __Block_byref_str_1 *str = __cself-&gt;str; <span class="comment">// bound by ref</span></span><br><span class="line"></span><br><span class="line">    (val-&gt;__forwarding-&gt;val)++;</span><br><span class="line">    (str-&gt;__forwarding-&gt;str) = (NSString *)&amp;__NSConstantStringImpl__var_folders_tr_t3h53q856n11q1hrk0gc6bgm0000gn_T_main_00d5a1_mi_2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原本我们代码中写的<code>val++</code>，clang重写之后变成了<code>(val-&gt;__forwarding-&gt;val)++</code>，然后再带上之前<code>__forwarding</code>指针指向的疑问，有点凌乱。。。一步一步捋过来吧，先run一下代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val初始化地址-0x7ffeefbff5e8</span><br><span class="line">str初始化地址-0x7ffeefbff5c8</span><br><span class="line">&lt;__NSMallocBlock__: 0x1007235f0&gt;</span><br><span class="line">val block地址-0x100723568</span><br><span class="line">str block地址-0x100523608</span><br></pre></td></tr></table></figure>
<p>执行完之后可以发现block已经变成了<code>NSMallocBlock</code>，而<code>val</code>和<code>str</code>的地址与block的地址相差很小，很大概率上他们也存在了堆区，然后结合下图去分析 <img src="https://raw.githubusercontent.com/sthyuhao/BlogImgZone/master/ff9b239d9e7036bbfcf7cecf4c4391.jpg" alt></p>
<p><code>__cself-&gt;val</code>指向的是栈区的<code>val</code>，但是block中<code>val</code>已经被复制到了堆区，堆区的<code>val</code>指向自己没有任何的问题，但是当访问的是栈区的<code>val</code>要怎样才能正确的访问到变量的值？<code>__forwarding</code> 被设计出来就是为了解决这个问题，如上图所示，栈区的 <code>__forwarding</code> 指向了复制到堆后的 <code>val</code> ，而堆上<code>val</code>指向自己，这也就保证了不论是访问栈还是堆上的<code>val</code>都能获取到正确的值。</p>
<p>再看看重写后的<code>(val-&gt;__forwarding-&gt;val)</code>，是不是已经明白了？</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/12/2018-11-12/" data-id="cju0vz2vl0000o4umwr6jwru0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/block/">block</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2018-10-31" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/01/2018-10-31/" class="article-date">
  <time datetime="2018-11-01T11:41:50.000Z" itemprop="datePublished">2018-11-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/内存管理/">内存管理</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/01/2018-10-31/">从源码分析Block的内存管理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>实际上我不知道怎么去起这个标题，文章大概讲述的是block的类型，block类型的转换以及block的释放，不管了先这样吧</p>
<h2 id="block的结构"><a href="#block的结构" class="headerlink" title="block的结构"></a>block的结构</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Block_layout</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *isa;</span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="keyword">int</span> reserved;</span><br><span class="line">    <span class="keyword">void</span> (*invoke)(<span class="keyword">void</span> *, ...);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Block_descriptor</span> *<span class="title">descriptor</span>;</span></span><br><span class="line">    <span class="comment">/* Imported variables. */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Block_descriptor</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> reserved;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">void</span> (*copy)(<span class="keyword">void</span> *dst, <span class="keyword">void</span> *src);</span><br><span class="line">    <span class="keyword">void</span> (*dispose)(<span class="keyword">void</span> *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Block的结构体如以上代码所示，第一个成员就是咱们熟悉的<code>isa</code>，所以你可以把block当成是一个对象来看待。在iOS中只会出现_NSConcreteStackBlock，_NSConcreteMallocBlock，_NSConcreteGlobalBlock三种类型的block。</p>
<p>第二个成员<code>flags</code>在之后的分析中充当这重要角色，通常标识着block当前的状态。</p>
<p>第五个成员是对block的补充描述，包含 <code>copy/dispose</code> 函数。</p>
<p>第六个成员…哪来的第六个成员？结构体中明明只标明了5个啊？/<em> Imported variables. </em>/表示block中可能会捕获一些变量。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> val = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">void</span> (^aBlock)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">            val ++;</span><br><span class="line">        &#125;;</span><br><span class="line">        aBlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写一个简单block，然后使用clang将源码重写成cpp文件<code>clang -rewrite-objc maim.m</code> ,同目录下得到一个main.cpp。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  <span class="keyword">int</span> *val;</span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, <span class="keyword">int</span> *_val, <span class="keyword">int</span> flags=<span class="number">0</span>) : val(_val) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  <span class="keyword">int</span> *val = __cself-&gt;val; <span class="comment">// bound by copy</span></span><br><span class="line"></span><br><span class="line">            (*val) ++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __main_block_impl_0)&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> val = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">void</span> (*aBlock)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, &amp;val));</span><br><span class="line">        ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)aBlock)-&gt;FuncPtr)((__block_impl *)aBlock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">IMAGE_INFO</span> &#123;</span> <span class="keyword">unsigned</span> version; <span class="keyword">unsigned</span> flag; &#125; _OBJC_IMAGE_INFO = &#123; <span class="number">0</span>, <span class="number">2</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>转成C++代码后可以看清整个block的构造，看看构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int *_val, int flags=0) : val(_val) &#123;</span><br><span class="line">  impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">  impl.Flags = flags;</span><br><span class="line">  impl.FuncPtr = fp;</span><br><span class="line">  Desc = desc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>出现了一个在结构体从未出现过的变量val，这个val就是我们需要在ablock中捕获的变量。<br>isa指向了_NSConcreteStackBlock，证明他是一个_NSConcreteStackBlock，那么_NSConcreteMallocBlock和_NSConcreteGlobalBlock会在什么时候出现？</p>
<p>先说说_NSConcreteGlobalBlock，这是一个存在内存全局区的block，在编译时就已经完全完成了，通常是不去捕获任何变量的block，也有说法说只访问静态变量或者全局变量的block也可以是_NSConcreteGlobalBlock，小弟才疏学浅，尚未证明这点。</p>
<p>_NSConcreteStackBlock 是一个存在栈区的block，当然他的名字就已经说明了这一点，他可以访问外部变量，且没有强指针引用。生命周期由系统控制。</p>
<p>_NSConcreteMallocBlock 是一个存在堆区的block，通常由NSConcreteStackBlock调用<code>_block_copy</code>将内存移到堆区。一般有强指针引用或者使用copy修饰的block都是NSConcreteMallocBlock。当没有强指针引用时销毁。</p>
<h2 id="block为什么要用copy修饰？"><a href="#block为什么要用copy修饰？" class="headerlink" title="block为什么要用copy修饰？"></a>block为什么要用copy修饰？</h2><p>在MRC环境下，如果block使用retain修饰在block内访问外部变量会出现crash，因为MRC环境下block初始化后会存在栈区，没有改变外部变量的能力。<br>ARC环境下block会被自动copy到堆区，从clang的ARC文档中我们可以看到这样的描述<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">With the exception of retains done as part of initializing a __strong parameter variable or reading a __weak variable, whenever these semantics call for retaining a value of block-pointer type, it has the effect of a Block_copy. The optimizer may remove such copies when it sees that the result is used only as an argument to a call.</span><br></pre></td></tr></table></figure></p>
<p>在ARC环境下编译器会自动触发</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">id <span class="title">objc_retainBlock</span><span class="params">(id x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (id)_Block_copy(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即使编译器会自动将我们创建的block推入堆区，但<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/WorkingwithBlocks/WorkingwithBlocks.html#//apple_ref/doc/uid/TP40011210-CH8-SW12" target="_blank" rel="noopener">苹果官方依然推荐我们使用copy来修饰block</a>。<br>之前访问过别人博客，有一条评论表示ARC环境下使用strong修饰依然会有crash的现象，但该条评论的作者已经忘了是什么情况下产生这种状况的了。但我们应该对代码保持一个敬畏之心，也许一个不经意间产生的bug就可能产生一个意想不到的后果。</p>
<h2 id="block是怎么被推入堆区的？"><a href="#block是怎么被推入堆区的？" class="headerlink" title="block是怎么被推入堆区的？"></a>block是怎么被推入堆区的？</h2><p>上面说到ARC环境下的block会被自动推入堆区，大致上是<code>objc_retainBlock()</code>调用了<code>_Block_copy（）</code>，那具体是怎么实现的呢？<br>emmm…先看看官方开源的<a href="https://opensource.apple.com/source/libclosure/libclosure-67/runtime.c.auto.html" target="_blank" rel="noopener">runtime.c</a>源码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy, or bump refcount, of a block.  If really copying, call the copy helper if present.</span></span><br><span class="line"><span class="keyword">void</span> *_Block_copy(<span class="keyword">const</span> <span class="keyword">void</span> *arg) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Block_layout</span> *<span class="title">aBlock</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  判断传入的block是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (!arg) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// The following would be better done as a switch statement</span></span><br><span class="line">    aBlock = (struct Block_layout *)arg;</span><br><span class="line">    <span class="keyword">if</span> (aBlock-&gt;flags &amp; BLOCK_NEEDS_FREE) &#123;</span><br><span class="line">        <span class="comment">// latches on high</span></span><br><span class="line">        <span class="comment">// 如果这个block是一个要被释放的block，当然这个block肯定是堆block了，既然你都有对象了，咱们也就没有继续谈下去的必要了，return</span></span><br><span class="line">        latching_incr_int(&amp;aBlock-&gt;flags);</span><br><span class="line">        <span class="keyword">return</span> aBlock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (aBlock-&gt;flags &amp; BLOCK_IS_GLOBAL) &#123;</span><br><span class="line">        <span class="comment">//  如果是个全局block，return</span></span><br><span class="line">        <span class="keyword">return</span> aBlock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Its a stack block.  Make a copy.</span></span><br><span class="line">        <span class="comment">//  如果是个栈block，那我们的故事就开始了</span></span><br><span class="line">        <span class="comment">//  首先当然是申请内存啦，之前的block占多大的内存，咱们就得占多大</span></span><br><span class="line">        struct Block_layout *result = <span class="built_in">malloc</span>(aBlock-&gt;descriptor-&gt;size);</span><br><span class="line">        <span class="comment">//  申请失败那自然拜拜咯</span></span><br><span class="line">        <span class="keyword">if</span> (!result) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//  memmove()将之前栈上所有的数据迁移到刚刚申请的内存上</span></span><br><span class="line">        memmove(result, aBlock, aBlock-&gt;descriptor-&gt;size); <span class="comment">// bitcopy first</span></span><br><span class="line">        <span class="comment">// reset refcount</span></span><br><span class="line">        <span class="comment">//  重设引用计数</span></span><br><span class="line">        result-&gt;flags &amp;= ~(BLOCK_REFCOUNT_MASK|BLOCK_DEALLOCATING);    <span class="comment">// XXX not needed</span></span><br><span class="line">        result-&gt;flags |= BLOCK_NEEDS_FREE | <span class="number">2</span>;  <span class="comment">// logical refcount 1</span></span><br><span class="line">        _Block_call_copy_helper(result, aBlock);</span><br><span class="line">        <span class="comment">// Set isa last so memory analysis tools see a fully-initialized object.</span></span><br><span class="line">        <span class="comment">//  最后将isa设置成_NSConcreteMallocBlock</span></span><br><span class="line">        result-&gt;isa = _NSConcreteMallocBlock;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码就是把block从栈区推入堆区的具体操作。<br>当然有retain就会有release。</p>
<h2 id="那block是怎么销毁的？"><a href="#那block是怎么销毁的？" class="headerlink" title="那block是怎么销毁的？"></a>那block是怎么销毁的？</h2><p>依然是runtime.c文件中，找到<code>_Block_release()</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// API entry point to release a copied Block</span></span><br><span class="line"><span class="keyword">void</span> _Block_release(<span class="keyword">const</span> <span class="keyword">void</span> *arg) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Block_layout</span> *<span class="title">aBlock</span> = (<span class="title">struct</span> <span class="title">Block_layout</span> *)<span class="title">arg</span>;</span></span><br><span class="line">    <span class="comment">//  依然以判断传入的block是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (!aBlock) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//  判断block是否是全局block</span></span><br><span class="line">    <span class="keyword">if</span> (aBlock-&gt;flags &amp; BLOCK_IS_GLOBAL) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//  判断是不是堆block</span></span><br><span class="line">    <span class="keyword">if</span> (! (aBlock-&gt;flags &amp; BLOCK_NEEDS_FREE)) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  走到这里，证明没有异常</span></span><br><span class="line">    <span class="comment">//  先加个锁，保证不被别的线程释放了</span></span><br><span class="line">    <span class="keyword">if</span> (latching_decr_int_should_deallocate(&amp;aBlock-&gt;flags)) &#123;</span><br><span class="line">        _Block_call_dispose_helper(aBlock);</span><br><span class="line">        <span class="comment">//  _Block_destructInstance好像没做啥事</span></span><br><span class="line">        _Block_destructInstance(aBlock);</span><br><span class="line">        <span class="comment">//  free</span></span><br><span class="line">        <span class="built_in">free</span>(aBlock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从栈到堆，然后到被释放其实也就这么些代码，实际上并不复杂。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/01/2018-10-31/" data-id="cju0vz2wz000ro4ummoy59j0s" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/block/">block</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2018-10-19" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/19/2018-10-19/" class="article-date">
  <time datetime="2018-10-19T03:53:26.000Z" itemprop="datePublished">2018-10-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/内存管理/">内存管理</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/19/2018-10-19/">weak到底做了些啥？</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="weak到底做了些啥？"><a href="#weak到底做了些啥？" class="headerlink" title="weak到底做了些啥？"></a>weak到底做了些啥？</h1><p>入行也好几年了，关于内存管理几乎是面试中必定会问到的问题，内存管理中问的最多的大概就是循环引用和weak的实现了，关于weak怎么将修饰的对象置为nil的，可能几年前的回答就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runtime维护了一个weak表，用于存储指向某个对象的所有weak指针。weak表其实是一个hash（哈希）表，Key是所指对象的地址，Value是weak指针的地址（这个地址的值是所指对象指针的地址）数组。</span><br></pre></td></tr></table></figure>
<p>再之后可能就是weak的三部曲：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、初始化时：runtime会调用objc_initWeak函数，初始化一个新的weak指针指向对象的地址。</span><br><span class="line">2、添加引用时：objc_initWeak函数会调用 objc_storeWeak() 函数， objc_storeWeak() 的作用是更新指针指向，创建对应的弱引用表。</span><br><span class="line">3、释放时，调用clearDeallocating函数。clearDeallocating函数首先根据对象地址获取所有weak指针地址的数组，然后遍历这个数组把其中的数据设为nil，最后把这个entry从weak表中删除，最后清理对象的记录。</span><br></pre></td></tr></table></figure>
<p>那么上面提及到的函数到底都做了些啥？</p>
<h2 id="objc-initWeak"><a href="#objc-initWeak" class="headerlink" title="objc_initWeak"></a>objc_initWeak</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> HaveOld &#123; DontHaveOld = <span class="literal">false</span>, DoHaveOld = <span class="literal">true</span> &#125;;</span><br><span class="line"><span class="keyword">enum</span> HaveNew &#123; DontHaveNew = <span class="literal">false</span>, DoHaveNew = <span class="literal">true</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">id <span class="title">objc_initWeak</span><span class="params">(id *location, id newObj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!newObj) &#123;</span><br><span class="line">        *location = nil;</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> storeWeak&lt;DontHaveOld, DoHaveNew, DoCrashIfDeallocating&gt;(location, (objc_object*)newObj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码块，我们可以知道<code>objc_initWeak</code>其实是<code>objc_storeWeak</code>的入口，他主要判断了修饰的对象是否有效，倘若是个无效对象，则直接将指针置为nil，返回nil。</p>
<h2 id="storeWeak"><a href="#storeWeak" class="headerlink" title="storeWeak"></a>storeWeak</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  更新weak变量</span></span><br><span class="line"><span class="comment">//  如果HaveOld是true，则该变量目前是有值的，反之则需要被清空，这个值可能会是nil</span></span><br><span class="line"><span class="comment">//  如果HaveNew是true，则改变量会被分配上一个新的值，这个值可能会是nil</span></span><br><span class="line"><span class="comment">//  如果crashIfDeallocating是true，则newObj正在deallocating的过程中或者newObj不支持若引用，该过程被停止</span></span><br><span class="line"><span class="comment">//  如果crashIfDeallocating是false，用nil存储</span></span><br><span class="line"><span class="keyword">enum</span> CrashIfDeallocating &#123;</span><br><span class="line">    DontCrashIfDeallocating = <span class="literal">false</span>, DoCrashIfDeallocating = <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;HaveOld haveOld, HaveNew haveNew, CrashIfDeallocating crashIfDeallocating&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> id <span class="title">storeWeak</span><span class="params">(id *location, objc_object *newObj)</span> </span>&#123;</span><br><span class="line">    assert(haveOld  ||  haveNew);</span><br><span class="line">    <span class="keyword">if</span> (!haveNew) assert(newObj == nil);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    声明预先初始化类</span></span><br><span class="line">    Class previouslyInitializedClass = nil;</span><br><span class="line">    <span class="comment">//    声明旧值</span></span><br><span class="line">    id oldObj;</span><br><span class="line">    <span class="comment">//    声明新旧SideTable</span></span><br><span class="line">    SideTable *oldTable;</span><br><span class="line">    SideTable *newTable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分别为新值旧值加锁</span></span><br><span class="line"> retry:</span><br><span class="line">    <span class="keyword">if</span> (haveOld) &#123;</span><br><span class="line">        oldObj = *location;</span><br><span class="line">        oldTable = &amp;SideTables()[oldObj];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        oldTable = nil;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (haveNew) &#123;</span><br><span class="line">        newTable = &amp;SideTables()[newObj];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newTable = nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SideTable::lockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  上面代码已将*location赋值给oldObj，两值应该保持一致，如果不相同，则证明oldObj可能在其他线程中被修改</span></span><br><span class="line">    <span class="keyword">if</span> (haveOld  &amp;&amp;  *location != oldObj) &#123;</span><br><span class="line">        <span class="comment">//  解锁，然后回到retry重新操作</span></span><br><span class="line">        SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line">        <span class="keyword">goto</span> retry;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  防止弱引用间的死锁</span></span><br><span class="line">    <span class="comment">//  通过 +initialize 保证所有弱引用的 isa 指向非空</span></span><br><span class="line">    <span class="keyword">if</span> (haveNew  &amp;&amp;  newObj) &#123;</span><br><span class="line">        Class cls = newObj-&gt;getIsa();</span><br><span class="line">        <span class="comment">//  判断isa指针不指向previouslyInitializedClass且已经初始化 (previouslyInitializedClass可能指向nil，也可能指向前一个cls的地址)</span></span><br><span class="line">        <span class="keyword">if</span> (cls != previouslyInitializedClass  &amp;&amp;  !((objc_class *)cls)-&gt;isInitialized()) &#123;</span><br><span class="line">            SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line">            <span class="comment">//  _class_getNonMetaClass 通过类或者元类，返回一个普通的类</span></span><br><span class="line">            <span class="comment">//  _class_initialize 会对没有初始化的类进行 +initialize</span></span><br><span class="line">            _class_initialize(_class_getNonMetaClass(cls, (id)newObj));</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//  如果该类已经完成了+initialize，那自然是最好的</span></span><br><span class="line">            <span class="comment">//  如果该类依然在执行+initialize中，则可能出现它觉得自己没有意识到自己在调用+initialize的过程中再次调用+initialize的可能性，我们需要对其添加保护策略</span></span><br><span class="line">            <span class="comment">//  对previouslyInitializedClass指针进行标记然后重试</span></span><br><span class="line">            previouslyInitializedClass = cls;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">goto</span> retry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果有旧值，清除旧值</span></span><br><span class="line">    <span class="keyword">if</span> (haveOld) &#123;</span><br><span class="line">        weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有新值，分配新值</span></span><br><span class="line">    <span class="keyword">if</span> (haveNew) &#123;</span><br><span class="line">        newObj = (objc_object *)weak_register_no_lock(&amp;newTable-&gt;weak_table, (id)newObj, location, crashIfDeallocating);</span><br><span class="line">        <span class="comment">//  如果弱引用存储被拒，weak_register_no_lock会返回nil</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 引用计数表中标记为弱引用</span></span><br><span class="line">        <span class="keyword">if</span> (newObj  &amp;&amp;  !newObj-&gt;isTaggedPointer()) &#123;</span><br><span class="line">            newObj-&gt;setWeaklyReferenced_nolock();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//  不要在别的地方设置location，这里会设置他</span></span><br><span class="line">        *location = (id)newObj;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (id)newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从以上代码可以看出<code>storeWeak</code>先是做了一系列的条件判断以及保护操作，之后对新值旧值进行了操作，简而言之就是清除旧值分配新值。</p>
<p>但是，这个<code>SideTable</code>是干啥的?</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SideTable</span> &#123;</span></span><br><span class="line">    <span class="comment">//  自旋锁</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> slock;</span><br><span class="line">    <span class="comment">//  引用计数表，为了防止内存泄漏，RefcountMap会隐藏它的指针</span></span><br><span class="line">    RefcountMap refcnts;</span><br><span class="line">    <span class="comment">//  全局弱引用表</span></span><br><span class="line">    <span class="keyword">weak_table_t</span> weak_table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个结构体包含了引用计数表和weak表，想必便是用于管理对象的引用计数和weak表的。</p>
<h2 id="weak-unregister-no-lock"><a href="#weak-unregister-no-lock" class="headerlink" title="weak_unregister_no_lock"></a>weak_unregister_no_lock</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 解除已经注册的弱引用</span></span><br><span class="line"><span class="comment"> * 将在引用对用依然存在，引用地址即将被移除的时候调用</span></span><br><span class="line"><span class="comment"> * 如果当前引用地址/引用对象不是一个活跃的弱引用，则什么都不做</span></span><br><span class="line"><span class="comment"> * 如果是0引用，则什么都不做</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param weak_table 全局弱引用表.</span></span><br><span class="line"><span class="comment"> * @param referent 引用对象.</span></span><br><span class="line"><span class="comment"> * @param referrer 引用地址.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">weak_unregister_no_lock</span><span class="params">(<span class="keyword">weak_table_t</span> *weak_table, id referent_id, id *referrer_id)</span> </span>&#123;</span><br><span class="line">    objc_object *referent = (objc_object *)referent_id;</span><br><span class="line">    objc_object **referrer = (objc_object **)referrer_id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak_entry_t</span> *entry;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!referent) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((entry = weak_entry_for_referent(weak_table, referent))) &#123;</span><br><span class="line">        remove_referrer(entry, referrer);</span><br><span class="line">        <span class="keyword">bool</span> empty = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//  判断当前弱引用是否处于活跃状态，如果活跃，则什么都不操作</span></span><br><span class="line">        <span class="keyword">if</span> (entry-&gt;out_of_line()  &amp;&amp;  entry-&gt;num_refs != <span class="number">0</span>) &#123;</span><br><span class="line">            empty = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//  如果引用地址依然存在，则什么都不操作</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (entry-&gt;inline_referrers[i]) &#123;</span><br><span class="line">                    empty = <span class="literal">false</span>; </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (empty) &#123;</span><br><span class="line">            weak_entry_remove(weak_table, entry);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  不要设置 *referrer = nil， objc_storeWeak() 需要改变这个值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>storeWeak</code>中清除旧值的操作调用了<code>weak_unregister_no_lock()</code>，该函数最后会调用<code>weak_entry_remove（）</code>将其从弱引用表中移除。<br>该函数首先判断了弱引用条目是否存在，然后判断对象是否处于活跃状态以及引用地址是否还存在，如果处于活跃状态或引用地址依然存在则不做任何操作，否则将该弱引用条目从弱引用表中清除。</p>
<h2 id="weak-register-no-lock"><a href="#weak-register-no-lock" class="headerlink" title="weak_register_no_lock"></a>weak_register_no_lock</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注册一对新的键值对（对象，弱引用指针），如果该对象还存在就创建一个新的弱引用对象入口</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param weak_table 全局弱引用表</span></span><br><span class="line"><span class="comment"> * @param referent 弱引用对象</span></span><br><span class="line"><span class="comment"> * @param referrer 弱引用指针地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">id <span class="title">weak_register_no_lock</span><span class="params">(<span class="keyword">weak_table_t</span> *weak_table, id referent_id, id *referrer_id, <span class="keyword">bool</span> crashIfDeallocating)</span> </span>&#123;</span><br><span class="line">    objc_object *referent = (objc_object *)referent_id;</span><br><span class="line">    objc_object **referrer = (objc_object **)referrer_id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!referent  ||  referent-&gt;isTaggedPointer()) <span class="keyword">return</span> referent_id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保引用对象是否有效</span></span><br><span class="line">    <span class="keyword">bool</span> deallocating;</span><br><span class="line">    <span class="comment">//  hasCustomRR()判断是否有使用自定义的retain/release/autorelease（自定义内存管理）等方法</span></span><br><span class="line">    <span class="keyword">if</span> (!referent-&gt;ISA()-&gt;hasCustomRR()) &#123;</span><br><span class="line">        <span class="comment">//  rootIsDeallocating 对象是否正在销毁</span></span><br><span class="line">        deallocating = referent-&gt;rootIsDeallocating();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//  SEL_allowsWeakReference 对象是否允许弱引用</span></span><br><span class="line">        BOOL (*allowsWeakReference)(objc_object *, SEL) = (BOOL(*)(objc_object *, SEL))</span><br><span class="line">        object_getMethodImplementation((id)referent, SEL_allowsWeakReference);</span><br><span class="line">        <span class="comment">// 判断referent弱引用方法是否被转发</span></span><br><span class="line">        <span class="keyword">if</span> ((IMP)allowsWeakReference == _objc_msgForward) &#123;</span><br><span class="line">            <span class="keyword">return</span> nil;</span><br><span class="line">        &#125;</span><br><span class="line">        deallocating = ! (*allowsWeakReference)(referent, SEL_allowsWeakReference);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  如果deallocating为true，处理一哈</span></span><br><span class="line">    <span class="keyword">if</span> (deallocating) &#123;</span><br><span class="line">        <span class="keyword">if</span> (crashIfDeallocating) &#123;</span><br><span class="line">            _objc_fatal(<span class="string">"Cannot form weak reference to instance (%p) of "</span></span><br><span class="line">                        <span class="string">"class %s. It is possible that this object was "</span></span><br><span class="line">                        <span class="string">"over-released, or is in the process of deallocation."</span>,</span><br><span class="line">                        (<span class="keyword">void</span>*)referent, object_getClassName((id)referent));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将对象存储，并记录地址</span></span><br><span class="line">    <span class="keyword">weak_entry_t</span> *entry;</span><br><span class="line">    <span class="comment">//  判断弱引用表是否存在referent</span></span><br><span class="line">    <span class="keyword">if</span> ((entry = weak_entry_for_referent(weak_table, referent))) &#123;</span><br><span class="line">        <span class="comment">//  为弱引用指针添加至weak_entry_t</span></span><br><span class="line">        append_referrer(entry, referrer);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//  如果不存在则新建一个weak_entry_t</span></span><br><span class="line">        <span class="keyword">weak_entry_t</span> new_entry(referent, referrer);</span><br><span class="line">        <span class="comment">//  如果weak_table表满了，就扩大控件</span></span><br><span class="line">        <span class="comment">//  当 weak_table 里的弱引用到达容量3/4时，会将容量拓展为两倍</span></span><br><span class="line">        weak_grow_maybe(weak_table);</span><br><span class="line">        <span class="comment">//  将弱引用插入表中</span></span><br><span class="line">        weak_entry_insert(weak_table, &amp;new_entry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不要设置 *referrer = nil，因为 objc_storeWeak() 函数会需要该指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> referent_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法先是判断引用是否有效，引用对象是否处于销毁中的状态，最后再判断弱引用表是否存在referent，存在则直接添加弱引用，不存在则先创建weak_entry_t，然后对表进行扩容（如果需要的话），最后将弱引用插入表中。不得不说源码层面的条件判断非常严谨，各个会出现异常位置都有一个条件判断。</p>
<p>以上就是weak分配值的一系列操作了，还有一个问题就是对象调用<code>dealloc</code>是怎么将弱引用变量置为nil的?</p>
<h2 id="自动置为nil"><a href="#自动置为nil" class="headerlink" title="自动置为nil"></a>自动置为nil</h2><p>ok,我们都知道当一个对象引用计数为0的时候会调用<code>dealloc</code>方法，那么以<code>dealloc</code>为入口，去看看究竟都发生了一些什么事情。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    _objc_rootDealloc(self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">_objc_rootDealloc(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    assert(obj);</span><br><span class="line"></span><br><span class="line">    obj-&gt;rootDealloc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">objc_object::rootDealloc()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span>;  <span class="comment">// fixme necessary?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fastpath(isa.nonpointer  &amp;&amp;  </span><br><span class="line">                 !isa.weakly_referenced  &amp;&amp;  </span><br><span class="line">                 !isa.has_assoc  &amp;&amp;  </span><br><span class="line">                 !isa.has_cxx_dtor  &amp;&amp;  </span><br><span class="line">                 !isa.has_sidetable_rc))</span><br><span class="line">    &#123;</span><br><span class="line">        assert(!sidetable_present());</span><br><span class="line">        <span class="built_in">free</span>(<span class="keyword">this</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        object_dispose((id)<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id </span><br><span class="line">object_dispose(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj) <span class="keyword">return</span> nil;</span><br><span class="line"></span><br><span class="line">    objc_destructInstance(obj);    </span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">objc_destructInstance</span><span class="params">(id obj)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        <span class="comment">// Read all of the flags at once for performance.</span></span><br><span class="line">        <span class="keyword">bool</span> cxx = obj-&gt;hasCxxDtor();</span><br><span class="line">        <span class="keyword">bool</span> assoc = obj-&gt;hasAssociatedObjects();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This order is important.</span></span><br><span class="line">        <span class="keyword">if</span> (cxx) object_cxxDestruct(obj);</span><br><span class="line">        <span class="keyword">if</span> (assoc) _object_remove_assocations(obj);</span><br><span class="line">        obj-&gt;clearDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用流程<br>dealloc -&gt; rootDealloc -&gt; object_dispose -&gt; objc_destructInstance -&gt; clearDeallocating</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> </span><br><span class="line">objc_object::clearDeallocating()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (slowpath(!isa.nonpointer)) &#123;</span><br><span class="line">        <span class="comment">// Slow path for raw pointer isa.</span></span><br><span class="line">        sidetable_clearDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (slowpath(isa.weakly_referenced  ||  isa.has_sidetable_rc)) &#123;</span><br><span class="line">        <span class="comment">// Slow path for non-pointer isa with weak refs and/or side table data.</span></span><br><span class="line">        clearDeallocating_slow();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert(!sidetable_present());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>clearDeallocating</code>中的判断表示弱引用会进入<code>clearDeallocating_slow()</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">NEVER_INLINE <span class="keyword">void</span></span><br><span class="line">objc_object::clearDeallocating_slow()</span><br><span class="line">&#123;</span><br><span class="line">    assert(isa.nonpointer  &amp;&amp;  (isa.weakly_referenced || isa.has_sidetable_rc));</span><br><span class="line"></span><br><span class="line">    SideTable&amp; table = SideTables()[<span class="keyword">this</span>];</span><br><span class="line">    table.lock();</span><br><span class="line">    <span class="keyword">if</span> (isa.weakly_referenced) &#123;</span><br><span class="line">        weak_clear_no_lock(&amp;table.weak_table, (id)<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isa.has_sidetable_rc) &#123;</span><br><span class="line">        table.refcnts.erase(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    table.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终弱引用会调用到<code>weak_clear_no_lock()</code></p>
<h3 id="weak-clear-no-lock"><a href="#weak-clear-no-lock" class="headerlink" title="weak_clear_no_lock"></a>weak_clear_no_lock</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 被dealnoc调用；清除弱引用指针</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param weak_table 弱引用表</span></span><br><span class="line"><span class="comment"> * @param referent 将要被销毁的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> </span><br><span class="line">weak_clear_no_lock(<span class="keyword">weak_table_t</span> *weak_table, id referent_id) </span><br><span class="line">&#123;</span><br><span class="line">    objc_object *referent = (objc_object *)referent_id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  先看看是不是没有弱引用</span></span><br><span class="line">    <span class="keyword">weak_entry_t</span> *entry = weak_entry_for_referent(weak_table, referent);</span><br><span class="line">    <span class="keyword">if</span> (entry == nil) &#123;</span><br><span class="line">        <span class="comment">/// XXX shouldn't happen, but does with mismatched CF/objc</span></span><br><span class="line">        <span class="comment">//printf("XXX no entry for clear deallocating %p\n", referent);</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// zero out references</span></span><br><span class="line">    <span class="keyword">weak_referrer_t</span> *referrers;</span><br><span class="line">    <span class="keyword">size_t</span> count;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  获取引用位置以及个数</span></span><br><span class="line">    <span class="keyword">if</span> (entry-&gt;out_of_line()) &#123;</span><br><span class="line">        referrers = entry-&gt;referrers;</span><br><span class="line">        count = TABLE_SIZE(entry);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        referrers = entry-&gt;inline_referrers;</span><br><span class="line">        count = WEAK_INLINE_COUNT;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  遍历弱引用数组，置nil</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">        objc_object **referrer = referrers[i];</span><br><span class="line">        <span class="keyword">if</span> (referrer) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*referrer == referent) &#123;</span><br><span class="line">                *referrer = nil;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (*referrer) &#123;</span><br><span class="line">                _objc_inform(<span class="string">"__weak variable at %p holds %p instead of %p. "</span></span><br><span class="line">                             <span class="string">"This is probably incorrect use of "</span></span><br><span class="line">                             <span class="string">"objc_storeWeak() and objc_loadWeak(). "</span></span><br><span class="line">                             <span class="string">"Break on objc_weak_error to debug.\n"</span>, </span><br><span class="line">                             referrer, (<span class="keyword">void</span>*)*referrer, (<span class="keyword">void</span>*)referent);</span><br><span class="line">                objc_weak_error();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  最后清除弱引用条目</span></span><br><span class="line">    weak_entry_remove(weak_table, entry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法获取了对象的所有弱引用变量，然后遍历弱引用数组，将这些变量分别置为nil。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/10/19/2018-10-19/" data-id="cju0vz2wy000qo4umfd7pwp4z" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/weak/">weak</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-initialize使用不当造成的问题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/19/initialize使用不当造成的问题/" class="article-date">
  <time datetime="2018-07-19T06:29:37.000Z" itemprop="datePublished">2018-07-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/19/initialize使用不当造成的问题/">initialize使用不当造成的问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="事件由来"><a href="#事件由来" class="headerlink" title="事件由来"></a>事件由来</h2><p>之前项目中有个让用户一边签署协议，一边录制视频上传的功能，当时法务同学要求的是只能直接拍摄上传，不能让用户在相册里直接选取，然后就有了只能拍摄视频上传的第一个版本。而当用户使用之后表示不能从相册中选取很不方便，有时签署协议过程中出了些问题的话又得重新操作一遍。<br>收到反馈之后，产品也迅速的给出了方案，在原来的的基础上添加一个本地上传的功能，于是我想到了个骚操作。<br> <img src="https://raw.githubusercontent.com/sthyuhao/BlogImgZone/master/90a661b390a70f702d3966c997c28b.jpg" alt="15319807710011"></p>
<p>原本这个拍照按钮调用的是系统的拍摄视频，但我直接给替换成了之前同事写的直接拍摄上传了。<br>考虑到之前做启动优化， <code>+load</code> 方法如果越多，app冷启动速度就会越慢，我就将搅拌方法放在了 <code>+initialize</code>中，然后，意想不到的bug发生了。</p>
<h2 id="BUG"><a href="#BUG" class="headerlink" title="BUG"></a>BUG</h2><p>测试小姐姐告诉我线上H5调用相机拍照调不起来，app直接卡死，daily调相机则会直接crash。然而native直接调用的话确是可以的。</p>
<h2 id="寻找原因"><a href="#寻找原因" class="headerlink" title="寻找原因"></a>寻找原因</h2><p>native调用的是 <code>PhotoSelectorViewControlle</code>,而H5调用的则是 <code>WebPhotoSelectorViewController</code>,这两个控制的关系就是 <code>WebPhotoSelectorViewController</code> 继承自 <code>PhotoSelectorViewControlle</code>。</p>
<p>在 <code>WebPhotoSelectorViewController</code> 的 <code>+initialize</code> 方法中下断点，如果native直接调用的话，改方法只执行了一遍，而H5调用的话 <code>+initialize</code> 却是执行了两遍，why ？？？<br><img src="https://raw.githubusercontent.com/sthyuhao/BlogImgZone/master/68defc1fe5023bc2ad7fd91c729f5c.jpg" alt="15319823192834"></p>
<p><img src="https://raw.githubusercontent.com/sthyuhao/BlogImgZone/master/a150f196c475382e14e6ccdad8ea30.jpg" alt="15319823744881"></p>
<p>以上两张图的执行结果表示了第一次方法替换是成功了，但第二次就出现问题了，方法变成了第一次已经替换成功之后的方法，然后在之后的方法就造成了死循环。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)swizz_pushImagePickerController &#123;</span><br><span class="line">    if (条件成立) &#123;</span><br><span class="line">        // doSomestring</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    [self swizz_pushImagePickerController];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么问题来了，为什么<code>+initialize</code>执行了两遍？</p>
<p>之前看load与initialize的异同的时候看见过一张图，<br><img src="https://raw.githubusercontent.com/sthyuhao/BlogImgZone/master/d6616f07de73db86246668d80ca8c4.jpg" alt="15319828915111"></p>
<p>如果子类未实现<code>+initialize</code>方法的话，是会沿用父类的实现的，这也就是为啥<code>+initialize</code>执行了两遍。<br><img src="https://raw.githubusercontent.com/sthyuhao/BlogImgZone/master/6eb9e370cb02cbbf3b979882bd8498.jpg" alt="15319830988438"></p>
<p>参照官方文档，<code>PhotoSelectorViewControlle</code>的initialize先执行了一遍，而<code>WebPhotoSelectorViewController</code>没有实现initialize，则再一次的执行了父类的initialize。如果不想子类调用父类的initialize，则需要和上图中代码款一样操作就行了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/19/initialize使用不当造成的问题/" data-id="cju0vz2w30006o4umvadokeij" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-一次逆向mac微信过程记录" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/17/一次逆向mac微信过程记录/" class="article-date">
  <time datetime="2018-04-17T03:04:02.000Z" itemprop="datePublished">2018-04-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/逆向/">逆向</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/17/一次逆向mac微信过程记录/">一次逆向mac微信过程记录（自动添加群聊好友）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一次逆向mac微信过程记录"><a href="#一次逆向mac微信过程记录" class="headerlink" title="一次逆向mac微信过程记录"></a>一次逆向mac微信过程记录</h1><p>最近产品搞事情，需要逆向mac微信来实现在群聊中自动添加客户的功能，用来爬取这些客户的朋友圈，刚听到这不靠谱的需求是嘴上笑嘻嘻心里mmp的，干些啥不好偏偏要在不是自己的app上搞事情，好在已有前辈给逆向微信铺了一条阳光大道，才能让这次开发顺利进行。</p>
<p><strong>本文内容基于TK前辈的<a href="https://github.com/TKkk-iOSer/WeChatPlugin-MacOS" target="_blank" rel="noopener">WeChatPlugin-MacOS</a></strong></p>
<p>OK，牢骚发完了，简单的说说这次逆向过程</p>
<h2 id="寻找切入点"><a href="#寻找切入点" class="headerlink" title="寻找切入点"></a>寻找切入点</h2><p><code>WeChatPlugin-MacOS</code>已经实现了消息自动回复的功能，看到有这个功能我是灰常嗨森的，等于说少了一大堆的分析过程，直接找到调用自动回复的消息同步方法<code>[MessageService OnSyncBatchAddMsgs:isFirstSync:]</code>,而且这个插件中也已经hook了该方法，直接在hook方法中添加我们的自动添加好友方法<code>autoAddFriendsWithMsg()</code>,到此方法的入口搞定了，再来分析发送好友申请是怎么实现的。</p>
<h2 id="寻找发送好友申请调用的方法"><a href="#寻找发送好友申请调用的方法" class="headerlink" title="寻找发送好友申请调用的方法"></a>寻找发送好友申请调用的方法</h2><p><code>WeChatPlugin-MacOS</code>已经在很多类中输出了log，但是日志太多了也很麻烦。<br>点击用户，然后弹出下图，点击添加好友按钮</p>
<p><img src="https://raw.githubusercontent.com/sthyuhao/BlogImgZone/master/1f29b6f5a45bb82f3cdccdf2e14667.jpg" alt></p>
<p>查看日志寻找我们想要的信息。在密密麻麻的日志中发现了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2018-04-17 10:01:37.019405+0800 WeChat[64662:2113668] [FriendRequest] MMFriendRequestMgr.mm __91-[MMFriendRequestMgr sendVerifyUserRequestWithUserName:opCode:verifyMsg:ticket:completion:]_block_invoke INFO: Send verify user cgi succ. opcode: 1 result: -44</span><br><span class="line">2018-04-17 10:01:37.019440+0800 WeChat[64662:2113668] [FriendRequest] MMFriendRequestMgr.mm __91-[MMFriendRequestMgr sendVerifyUserRequestWithUserName:opCode:verifyMsg:ticket:completion:]_block_invoke INFO: Need verify</span><br><span class="line">WeChat                          0x10049384d __67-[MMFriendRequestMgr addNewFriendWithContact:verifyMsg:completion:]_block_invoke + 79</span><br><span class="line">WeChat                          0x1004949f7 __91-[MMFriendRequestMgr sendVerifyUserRequestWithUserName:opCode:verifyMsg:ticket:completion:]_block_invoke + 1204</span><br></pre></td></tr></table></figure></p>
<p><code>[MMFriendRequestMgr addNewFriendWithContact:verifyMsg:completion:]</code> 确认过眼神，我遇上对的人<br>hook该方法，输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arg1:UsrName:wxid_xxxxxxxx, Nickname:XXXXX, Remark:(null), Sex:0, Type:4, imgStatus:IMG_HAS </span><br><span class="line">arg2:nil</span><br></pre></td></tr></table></figure></p>
<p>从日志大概就能分析出arg1应该就是<code>WCContactData</code>的数据模型<br>arg2则是添加好友发送给对方看的验证信息<br>block干了些啥暂时不用去关心</p>
<p><strong>那么新的问题就出现了，如何在消息同步方法中获取到发送信息用户的<code>WCContactData</code>的数据模型？</strong></p>
<p><img src="https://raw.githubusercontent.com/sthyuhao/BlogImgZone/master/0045b0a26301973f13a84184f0a2b9.jpg" alt></p>
<p>上图为<code>AddMsg</code>消息模型</p>
<p>从<code>AddMsg</code>中我们能获取到用户的sessionId（也就是UsrName），Nickname，消息内容等信息，但怎样才能通过这些信息拿到我们想要的<code>WCContactData</code>数据模型？</p>
<p>在<code>WeChatPlugin-MacOS</code>中自动回复方法有调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ContactStorage *contactStorage = [[objc_getClass(&quot;MMServiceCenter&quot;) defaultCenter] getService:objc_getClass(&quot;ContactStorage&quot;)];</span><br><span class="line">    WCContactData *msgContact = [contactStorage GetContact:addMsg.fromUserName.string];</span><br></pre></td></tr></table></figure></p>
<p>获取<code>WCContactData</code>数据模型，但在群聊中<code>addMsg.fromUserName.string</code>是<code>xxxxxx@ChatRoom</code>这样形式的字符串，也就说明以上方法并不适用于我们的场景。</p>
<p>回到微信群聊界面，通过点击用户头像是能够获取到用户的<code>WCContactData</code>的，那么通过点击操作是怎么获取到的？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2018-04-17 10:40:42.602165+0800 WeChat[64662:2113668] [Contact] GroupStorage+Internal.mm -[GroupStorage(Internal) OnModGroupMemberContacts_Thread:] DEBUG: onModGroupMemberContacts (</span><br><span class="line">    &quot;UsrName:wxid_xxxxxxxx, Nickname:XXXX, Remark:(null), Sex:0, Type:4, imgStatus:IMG_HAS&quot;</span><br><span class="line">)</span><br><span class="line">2018-04-17 10:40:42.602203+0800 WeChat[64662:2113668] [Contact] GroupStorage+Internal.mm -[GroupStorage(Internal) modifyGroupMembersContact:onlyInsertNew:] INFO: modify group member contact onMod. isOnlyInsertNew=0, memberscount=1</span><br><span class="line">2018-04-17 10:40:42.614908+0800 WeChat[64662:2113668] [MMChatDetailPanel] MMChatDetailPanel.mm -[MMChatDetailPanel OnModifyGroupMemberContact:] INFO: Group member contact modified UsrName:wxid_xxxxxxxx, Nickname:XXXX, Remark:(null), Sex:0, Type:4, imgStatus:IMG_HAS</span><br><span class="line">2018-04-17 10:40:42.615624+0800 WeChat[64662:2113668] [Contact] GroupStorage.mm -[GroupStorage GetGroupMemberContactFromSvrWithUsername:groupUserName:] INFO: GetGroupMemberContactFromSvr memberName=wxid_xxxxxxxx</span><br></pre></td></tr></table></figure></p>
<p>从点击事件中我们发现了以上几个方法可能对我们有用。<br>打开hooper分析了一通之后，发现并没什么卵用。。<br>但是<code>GroupStorage</code>还值得我们去探索一哈，打开<code>class-dump</code>之后的<code>GroupStorage.h</code>文件，一头扎进去寻找有返回值的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (id)GetGroupMemberListWithGroupUserName:(id)arg1;</span><br><span class="line">- (id)GetGroupMemberListWithGroupUserName:(id)arg1 limit:(unsigned int)arg2;</span><br><span class="line">- (id)GetGroupContactList:(unsigned int)arg1 ContactType:(unsigned int)arg2;</span><br><span class="line">- (id)GetGroupMemberContact:(id)arg1;</span><br><span class="line">- (id)GetGroupContactsWithUserNames:(id)arg1;</span><br><span class="line">- (id)GetGroupContact:(id)arg1;</span><br><span class="line">···</span><br></pre></td></tr></table></figure></p>
<p>通过方法名应该能看出些什么了吧，hook<code>- (id)GetGroupMemberContact:(id)arg1;</code><br>发现返回值就是我们要找的她！！！</p>
<p>那首歌怎么唱的来着，我要找到你不管南北东西，直觉会给我指引！！！</p>
<p>最后附上代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> 自动添加好友</span><br><span class="line"></span><br><span class="line"> @param addMsg 接收的消息</span><br><span class="line"> */</span><br><span class="line">- (void)autoAddFriendsWithMsg:(AddMsg *)addMsg &#123;</span><br><span class="line">    if (addMsg.msgType != 1 &amp;&amp; addMsg.msgType != 3) return;</span><br><span class="line">  </span><br><span class="line">    NSString *userName = @&quot;&quot;;</span><br><span class="line">    NSRange range = [addMsg.content.string rangeOfString:@&quot;:\n&quot;];</span><br><span class="line">    if (range.length &gt; 0) &#123;</span><br><span class="line">        userName = [addMsg.content.string substringToIndex:range.location];</span><br><span class="line">    &#125;</span><br><span class="line">    GroupStorage *groupStorage = [[objc_getClass(&quot;MMServiceCenter&quot;) defaultCenter] getService:objc_getClass(&quot;GroupStorage&quot;)];</span><br><span class="line">    //  根据sessionId获取联系人contact模型</span><br><span class="line">    WCContactData *msgContact = [groupStorage GetGroupMemberContact:userName];</span><br><span class="line">    MMFriendRequestMgr *friendReqMgr = [[objc_getClass(&quot;MMServiceCenter&quot;) defaultCenter] getService:objc_getClass(&quot;MMFriendRequestMgr&quot;)];</span><br><span class="line">    [friendReqMgr addNewFriendWithContact:msgContact verifyMsg:@&quot;兄弟，加个好友&quot; completion:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/17/一次逆向mac微信过程记录/" data-id="cju0vz2w9000ao4umoz67g8ve" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/逆向/">逆向</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-记录一次APP启动优化" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/11/记录一次APP启动优化/" class="article-date">
  <time datetime="2018-04-11T06:12:22.000Z" itemprop="datePublished">2018-04-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/优化/">优化</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/11/记录一次APP启动优化/">记录一次APP启动优化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>项目日渐庞大，代码越来越烦杂，性能问题也越来越多，准备搞一次系统性的优化。<br>随着加载项的越来越多，app启动时感觉有很明显的卡顿现象。<br>要做优化，先得分析APP是如何完成一次启动的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t(App总启动时间) = t1(main()之前的加载时间) + t2(main()之后的加载时间)。</span><br></pre></td></tr></table></figure>
<p>So,我们先分析下main()加载之前的过程。</p>
<p>在<code>target</code>中添加一个<code>value</code>为1的<code>DYLD_PRINT_STATISTICS</code>环境变量。<br><img src="https://raw.githubusercontent.com/sthyuhao/BlogImgZone/master/9f847b8fd004e409e1a177863e3d33.jpg" alt></p>
<p>run一哈，控制台输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Total pre-main time: 532.27 milliseconds (100.0%)</span><br><span class="line">         dylib loading time: 156.04 milliseconds (29.3%)</span><br><span class="line">        rebase/binding time:  74.47 milliseconds (13.9%)</span><br><span class="line">            ObjC setup time: 155.44 milliseconds (29.2%)</span><br><span class="line">           initializer time: 146.19 milliseconds (27.4%)</span><br><span class="line">           slowest intializers :</span><br><span class="line">             libSystem.B.dylib :  15.71 milliseconds (2.9%)</span><br><span class="line">    libMainThreadChecker.dylib :  18.48 milliseconds (3.4%)</span><br></pre></td></tr></table></figure>
<p>word妈耶!!! 在<code>main()</code>执行之前居然就用了532.27ms（需以冷启动的耗时为基准）。</p>
<p>从日志上可以看到大致的过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">加载dylib</span><br><span class="line">Rebase &amp;&amp; Bind （ASLR指针地址偏移，Rebase修正内部指针指向，Bind修正外部指针指向）</span><br><span class="line">初始化Objective C</span><br><span class="line">其它的初始化代码</span><br></pre></td></tr></table></figure>
<p>根据以上过程能得出影响<code>pre-main()</code>耗时的主要因素如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 动态库加载越多，启动越慢。</span><br><span class="line">* ObjC类越多，启动越慢</span><br><span class="line">* +load越多，启动越慢</span><br></pre></td></tr></table></figure>
<p>那么在<code>pre-main()</code>这一步我们都能做些什么优化工作？</p>
<p><strong>加载dylib</strong><br>在这一步我们能优化的不多，无非是减少一些动态库的依赖。</p>
<p><strong>Rebase &amp;&amp; Bind</strong><br>因为ASLR的存在，可执行文件在虚拟内存中的地址每次启动都是不同的，所以需要根据偏移量来计算正确的地址。这一步可以优化的点是移除不用的类和减少Catagory和selector的数量。</p>
<p>可以使用<a href="https://github.com/dblock/fui" target="_blank" rel="noopener">FUI</a>来寻找没有使用到的类，也可以使用<a href="https://www.jetbrains.com/objc/" target="_blank" rel="noopener">AppCode</a>来寻找，这里推荐使用<code>AppCode</code>，能相对安全的移除无效引用和方法等。当然，命中之后也得小心移除，以免出现意外。<br><img src="https://raw.githubusercontent.com/sthyuhao/BlogImgZone/master/68c665087d8d1ae5fc7bf0fec0144d.jpg" alt></p>
<p>上图为未优化前执行结果</p>
<p><img src="https://raw.githubusercontent.com/sthyuhao/BlogImgZone/master/bee28714b7c985a21c50a6ddae1e99.jpg" alt></p>
<p>上图为优化之后执行结果<br>经过一系列瞎比操作之后，删除了一些不必要的第三方库，大概移除了70+的无效类，900+无效方法，有些意外的是未使用的属性反而增加了。<code>pre-main</code>大概优化到了<code>330ms</code>左右，虽然优化到了推荐的<code>400ms</code>以内，但还是差强人意，待继续优化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Total pre-main time: 329.34 milliseconds (100.0%)</span><br><span class="line">         dylib loading time:  90.18 milliseconds (27.3%)</span><br><span class="line">        rebase/binding time:  58.19 milliseconds (17.6%)</span><br><span class="line">            ObjC setup time:  56.01 milliseconds (17.0%)</span><br><span class="line">           initializer time: 124.79 milliseconds (37.8%)</span><br><span class="line">           slowest intializers :</span><br><span class="line">             libSystem.B.dylib :  20.23 milliseconds (6.1%)</span><br><span class="line">   libBacktraceRecording.dylib :  10.15 milliseconds (3.0%)</span><br><span class="line">    libMainThreadChecker.dylib :  33.22 milliseconds (10.0%)</span><br></pre></td></tr></table></figure>
<p><strong>初始化Objective C</strong><br>上一步优化完之后这里也就没啥可做的了</p>
<p><strong>其它的初始化代码</strong><br>这一步开始动态调整<br>使用+initialize替换+load,从而加快所有类文件的加载速度.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/11/记录一次APP启动优化/" data-id="cju0vz2x3000wo4umwn8jcfej" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/优化/">优化</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Xcode集成O-LLVM" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/03/Xcode集成O-LLVM/" class="article-date">
  <time datetime="2017-08-03T09:05:37.000Z" itemprop="datePublished">2017-08-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LLVM/">LLVM</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/03/Xcode集成O-LLVM/">Xcode集成O-LLVM</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>要在Xcode中使用O-LLVM，必须要编写一个Xcode插件。</p>
<p>首先</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cd /Applications/Xcode.app/Contents/PlugIns/Xcode3Core.ideplugin/Contents/SharedSupport/Developer/Library/Xcode/Plug-ins/</span><br><span class="line">$ sudo cp -r Clang\ LLVM\ 1.0.xcplugin/ Obfuscator.xcplugin</span><br><span class="line">$ cd Obfuscator.xcplugin/Contents/</span><br><span class="line">$ sudo plutil -convert xml1 Info.plist</span><br><span class="line">$ sudo vim Info.plist</span><br></pre></td></tr></table></figure>
<p>更改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;string&gt;com.apple.compilers.clang&lt;/string&gt; -&gt; &lt;string&gt;com.apple.compilers.obfuscator&lt;/string&gt;</span><br><span class="line">&lt;string&gt;Clang LLVM 1.0 Compiler Xcode Plug-in&lt;/string&gt; -&gt; &lt;string&gt;Obfuscator Xcode Plug-in&lt;/string&gt;</span><br></pre></td></tr></table></figure>
<p>然后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo plutil -convert binary1 Info.plist</span><br><span class="line">$ cd Resources/</span><br><span class="line">$ sudo mv Clang\ LLVM\ 1.0.xcspec Obfuscator.xcspec</span><br><span class="line">$ sudo vim Obfuscator.xcspec</span><br></pre></td></tr></table></figure>
<p>更改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;key&gt;Description&lt;/key&gt;</span><br><span class="line">&lt;string&gt;Apple LLVM 8.0 compiler&lt;/string&gt; -&gt; &lt;string&gt;Obfuscator 4.0 compiler&lt;/string&gt;</span><br><span class="line">&lt;key&gt;ExecPath&lt;/key&gt;</span><br><span class="line">&lt;string&gt;clang&lt;/string&gt; -&gt; &lt;string&gt;/path/to/obfuscator_bin/clang&lt;/string&gt;</span><br><span class="line">&lt;key&gt;Identifier&lt;/key&gt;</span><br><span class="line">&lt;string&gt;com.apple.compilers.llvm.clang.1_0&lt;/string&gt; -&gt; &lt;string&gt;com.apple.compilers.llvm.obfuscator.4_0&lt;/string&gt;</span><br><span class="line">&lt;key&gt;Name&lt;/key&gt;</span><br><span class="line">&lt;string&gt;Apple LLVM 8.0&lt;/string&gt; -&gt; &lt;string&gt;Obfuscator 4.0&lt;/string&gt;</span><br><span class="line">&lt;key&gt;Vendor&lt;/key&gt;</span><br><span class="line">&lt;string&gt;Apple&lt;/string&gt; -&gt; &lt;string&gt;HEIG-VD&lt;/string&gt;</span><br><span class="line">&lt;key&gt;Version&lt;/key&gt;</span><br><span class="line">&lt;string&gt;7.0&lt;/string&gt; -&gt; &lt;string&gt;4.0&lt;/string&gt;</span><br></pre></td></tr></table></figure>
<p>然后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cd English.lproj/</span><br><span class="line">$ sudo mv Apple\ LLVM\ 5.1.strings &quot;Obfuscator 3.4.strings&quot;</span><br><span class="line">$ sudo plutil -convert xml1 Obfuscator\ 3.4.strings</span><br><span class="line">$ sudo vim Obfuscator\ 3.4.strings</span><br></pre></td></tr></table></figure>
<p>更改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;key&gt;Description&lt;/key&gt;</span><br><span class="line">&lt;string&gt;Apple LLVM 8.0 compiler&lt;/string&gt; -&gt; &lt;string&gt;Obfuscator 4.0 compiler&lt;/string&gt;</span><br><span class="line">&lt;key&gt;Name&lt;/key&gt;</span><br><span class="line">&lt;string&gt;Apple LLVM 8.0&lt;/string&gt; -&gt; &lt;string&gt;Obfuscator 4.0&lt;/string&gt;</span><br><span class="line">&lt;key&gt;Vendor&lt;/key&gt;</span><br><span class="line">&lt;string&gt;Apple&lt;/string&gt; -&gt; &lt;string&gt;HEIG-VD&lt;/string&gt;</span><br><span class="line">&lt;key&gt;Version&lt;/key&gt;</span><br><span class="line">&lt;string&gt;7.0&lt;/string&gt; -&gt; &lt;string&gt;4.0&lt;/string&gt;</span><br></pre></td></tr></table></figure>
<p>然后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo plutil -convert binary1 Obfuscator\ 3.4.strings</span><br></pre></td></tr></table></figure>
<p>完成以上操作后重启Xcode，然后随便打开一个project，在Build Settings中更换新的编译器：<br><img src="https://raw.githubusercontent.com/sthyuhao/BlogImgZone/master/edb4446996ab69e340e1538f7932c0.jpg" alt></p>
<p>将默认的编译器选项更换成Obfuscator 4.0(当然，根据你们git-clone下来的版本为准)。</p>
<p>然后<br>我们可以添加你想要的混淆方式的标志<br><img src="https://raw.githubusercontent.com/sthyuhao/BlogImgZone/master/037a575f397b6e5f81f645ccaba04b.jpg" alt></p>
<p>目前O-LLVM提供的方式有三种，分别是<br>指令替换 <code>-mllvm -sub</code><br>控制流伪造 <code>-mllvm -bcf</code><br>控制流平展 <code>-mllvm -fla</code></p>
<p>具体的替换模式请查阅<a href="https://github.com/obfuscator-llvm/obfuscator/wiki" target="_blank" rel="noopener">官方WIKI</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/08/03/Xcode集成O-LLVM/" data-id="cju0vz2vz0005o4umi3ysvzbw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/O-LLVM/">O-LLVM</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    <!-- Featured Tags -->

  
    <!-- Short About -->
<section class="visible-md visible-lg">
    <h5><a href="/about/">ABOUT ME</a></h5>
    <div class="short-about">

        

        

        <!-- SNS Link -->
        <ul class="list-inline">
            
            
            

            

            

            
            
            
            
        </ul>
    </div>
</section>
  
    
  <h5>RECENT POSTS
  <div class="widget">
    <ul>
      
        <li>
          <a href="/2019/03/20/2019-03-20/">扒一扒Category以及关联对象</a>
        </li>
      
        <li>
          <a href="/2019/02/13/2019-02-13/">年初的一些感慨</a>
        </li>
      
        <li>
          <a href="/2018/12/21/2018-12-21/">集成Hikari问题汇总</a>
        </li>
      
        <li>
          <a href="/2018/11/12/2018-11-12/">解析__block</a>
        </li>
      
        <li>
          <a href="/2018/11/01/2018-10-31/">从源码分析Block的内存管理</a>
        </li>
      
    </ul>
  </div>
</h5>
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Category/">Category</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/LLVM/">LLVM</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/block/">block</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/优化/">优化</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/内存管理/">内存管理</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/混淆/">混淆</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/逆向/">逆向</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔杂谈/">随笔杂谈</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>


  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 余果<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>



<script src="/js/script.js"></script>

  </div>
</body>
</html>