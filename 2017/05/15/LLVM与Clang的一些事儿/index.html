<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    
    <title>余生</title>
    <meta name="renderer" content="webkit">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <meta name="description" content="我是如来佛祖玉皇大帝观音菩萨指定取西经特派使者花果山水帘洞美猴王齐天大圣孙悟空，帅的掉渣！">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="余生">
    <meta name="twitter:description" content="我是如来佛祖玉皇大帝观音菩萨指定取西经特派使者花果山水帘洞美猴王齐天大圣孙悟空，帅的掉渣！">

    <meta property="og:type" content="article">
    <meta property="og:title" content="余生">
    <meta property="og:description" content="我是如来佛祖玉皇大帝观音菩萨指定取西经特派使者花果山水帘洞美猴王齐天大圣孙悟空，帅的掉渣！">

    
    <meta name="author" content="眯大帅">
    
    <link rel="stylesheet" href="/css/vno.css">
    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css">

    
    <link rel="icon" href="/images/avatar-small.png">
    

    <meta name="generator" content="hexo"/>
    

    <link rel="canonical" href="http://yoursite.com/2017/05/15/LLVM与Clang的一些事儿/"/>

    
      
</head>

<body class="home-template no-js">
    <script src="//cdn.bootcss.com/jquery/2.1.4/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>

    
<header class="panel-cover panel-cover--collapsed" style="background-image: url(/images/background-cover.jpg)">
  <div class="panel-main">
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        <a href="/" title="前往 余生 的主页"><img src="/images/avatar.jpg" width="80" alt="余生 logo" class="panel-cover__logo logo" /></a>
        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage for 余生">余生</a></h1>
        
        <hr class="panel-cover__divider" />
        <p class="panel-cover__description">简书：http://www.jianshu.com/u/bdf4a5f600a3</p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />

        <div class="navigation-wrapper">
          <div>
          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">
              <li class="navigation__item"><a href="/#blog" title="访问博客" class="blog-button">博客</a></li>
            
            </ul>
          </nav>
          </div>
          <div>
          <nav class="cover-navigation navigation--social">
  <ul class="navigation">

  <!-- Weibo-->
  

  <!-- Github -->
  
  <li class="navigation__item">
    <a href="https://github.com/sthyuhao" title="查看我的GitHub主页" target="_blank">
      <i class='social fa fa-github'></i>
      <span class="label">Github</span>
    </a>
  </li>


<!-- Stack Overflow -->
        

  <!-- Google Plus -->
  

<!-- Facebook -->

  
<!-- Twitter -->

  



  </ul>
</nav>

          </div>
        </div>

      </div>

    </div>

    <div class="panel-cover--overlay cover-purple"></div>
  </div>
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single">

  <header class="post-header">
    <div class="post-meta">
      <time datetime="2017-05-15T08:55:52.000Z" class="post-list__meta--date date">2017-05-15</time> &#8226; <span class="post-meta__tags tags">于&nbsp; </span>
      <span class="page-pv">
      &nbsp;阅读&nbsp;<span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span>
      </span> 
   
    </div>
    <h1 class="post-title"></h1>
  </header>

  <section class="post">
    <h1 id="LLVM与Clang的一些事儿"><a href="#LLVM与Clang的一些事儿" class="headerlink" title="LLVM与Clang的一些事儿"></a>LLVM与Clang的一些事儿</h1><p>在说这篇文章之前，首先我们带入一个问题，在Xcode中我们最常使用的一个组合键<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">又或者我不了解编译过程代码照样撸得飞起，摸透这晦涩难理解的东西有什么用？</div><div class="line"></div><div class="line">下面要开始啰嗦了</div><div class="line">--------------------------------------</div><div class="line">### LLVM简介-来自https://zh.wikipedia.org/wiki/LLVM</div><div class="line">LLVM项目的发展起源于2000年伊利诺伊大学厄巴纳-香槟分校维克拉姆·艾夫（Vikram Adve）与克里斯·拉特纳（Chris Lattner）的研究，他们想要为所有静态及动态语言创造出动态的编译技术。LLVM是以BSD授权来发展的开源软件。2005年，苹果电脑雇用了克里斯·拉特纳及他的团队为苹果电脑开发应用程序系统，LLVM为现今Mac OS X及iOS开发工具的一部分。</div><div class="line"></div><div class="line">LLVM的命名最早源自于底层虚拟机（Low Level Virtual Machine）的首字母缩写，由于这个项目的范围并不局限于创建一个虚拟机，这个缩写导致了广泛的疑惑。LLVM开始成长之后，成为众多编译工具及低级工具技术的统称，使得这个名字变得更不贴切，开发者因而决定放弃这个缩写的意涵，现今LLVM已单纯成为一个品牌，适用于LLVM下的所有项目，包含LLVM中介码（LLVM IR）、LLVM除错工具、LLVM C++标准库等。</div><div class="line"></div><div class="line">--------------------------------------</div><div class="line">### 关于swift之父加入Apple有个有趣的故事</div></pre></td></tr></table></figure></p>
<p>Xcode3之前，用的是GCC<br>Xcode3,GCC仍然保留，但是也推出了LLVM，苹果推荐LLVM-GCC混合编译器，但还不是默认编译器<br>Xcode4,LLVM-GCC成为默认编译器，但GCC仍保留<br>Xcode4.2,LLVM3.0成为默认编译器,纯用GCC不复可能<br>Xcode4.6,LLVM升级到4.2版本<br>Xcode5,LLVM-GCC被遗弃，新的编译器是LLVM5.0，从GCC过渡到LLVM的时代正式完成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">当时苹果对Objective-C新增了许多特性，但这时的Apple使用的是当时一手遮天的GCC作为前端。GCC并不为这些新特性买账--不给实现，因此索性后来两者 分成两条分支分别开发，这也造成Apple的编译器版本远落后于GCC的官方版本。并且GCC的代码耦合度太高，不好独立，而且越是后期的版本，代码质量越差7，但Apple想做的很多功能（比如更好的IDE支持）需要模块化的方式来调用GCC，但GCC一直不给做。《GCC运行环境豁免条款 （英文版）8》从根本上限制了LLVM-GCC的开发。 所以，这种不和让Apple一直在寻找一个高效的、模块化的、协议更放松的开源替代品。而UIUC的高材生Chris Lattner的LLVM显然是一个很棒的选择。</div><div class="line"></div><div class="line">-----------------------------------</div><div class="line">### Clang - a C language family frontend for LLVM</div><div class="line">Clang（发音为/ˈklæŋ/） 是一个C、C++、Objective-C和Objective-C++编程语言的编译器前端。它采用了底层虚拟机（LLVM）作为其后端。它的目标是提供一个GNU编译器套装（GCC）的替代品。作者是克里斯·拉特纳，在苹果公司的赞助支持下进行开发，而源代码授权是使用类BSD的伊利诺伊大学厄巴纳-香槟分校开源码许可。</div><div class="line">Clang项目包括Clang前端和Clang静态分析器等。</div><div class="line"></div><div class="line">Clang的在出生之前就已经明确了他的使命——干掉该死的GCC。有了LLVM+Clang，从此，苹果的开发面貌焕然一新。从此摆脱了GCC的限制。客观的说GCC是有很多的优点，例如支持多平台，很流行，基于C无需C++编译器即可编译。这些优点到苹果那就可能是缺点了，苹果需要的是——快。这正是Clang的优点，除了快，它还有与GCC兼容，内存占用小，诊断信息可读性强，易扩展，易于IDE集成等等优点。有个测试数据:Clang编译Objective-C代码时速度为GCC的3倍。</div><div class="line"></div><div class="line">--------------</div><div class="line">### LLDB</div><div class="line">GCC有个强大的诊断工具——GDB，相对应的Clang下纠错工具就是LLDB。对于LLDB大家应该都不陌生，它继承了GDB的优点，弥补GDB的不足。iOS开发者从gbd过渡到lldb没有任何不适应感，最直白的原因就是lldb和gdb常用的命令很多都是一样的，例如常用的po等。</div><div class="line"></div><div class="line">##啰嗦到此结束</div><div class="line"></div><div class="line">### iOS编译过程</div><div class="line">![](media/14948385529165/14948462465648.jpg)</div><div class="line">Objective-C与swift都采用Clang作为编译器前端，编译器前端主要进行语法分析，语义分析，生成中间代码，在这个过程中，会进行类型检查，如果发现错误或者警告会标注出来在哪一行。</div><div class="line">![](media/14948385529165/14948469406674.png)</div><div class="line">编译器后端会进行机器无关的代码优化，生成机器语言，并且进行机器相关的代码优化，根据不同的系统架构生成不同的机器码。</div><div class="line"></div><div class="line">C++,Objective C都是编译语言。编译语言在执行的时候，必须先通过编译器生成机器码。</div><div class="line"></div><div class="line"></div><div class="line">![](media/14948385529165/14962865484102.jpg)</div><div class="line">如上图所示，在xcode按下cmd+B之后的工作流程。</div><div class="line"></div><div class="line">**预处理（Pre-process）**：他的主要工作就是将宏替换，删除注释展开头文件，生成.i文件。</div><div class="line">**词法分析 （Lexical Analysis）**：将代码切成一个个 token，比如大小括号，等于号还有字符串等。是计算机科学中将字符序列转换为标记序列的过程。</div><div class="line">**语法分析（Semantic Analysis）**：验证语法是否正确，然后将所有节点组成抽象语法树 AST 。由 Clang 中 Parser 和 Sema 配合完成</div><div class="line">**静态分析（Static Analysis）**：使用它来表示用于分析源代码以便自动发现错误。</div><div class="line">**中间代码生成（Code Generation）**：开始IR中间代码的生成了，CodeGen 会负责将语法树自顶向下遍历逐步翻译成 LLVM IR，IR 是编译过程的前端的输出后端的输入。</div><div class="line">**优化（Optimize）**：LLVM 会去做些优化工作，在 Xcode 的编译设置里也可以设置优化级别-01，-03，-0s，还可以写些自己的 Pass，官方有比较完整的 Pass 教程： Writing an LLVM Pass — LLVM 5 documentation 。如果开启了 bitcode 苹果会做进一步的优化，有新的后端架构还是可以用这份优化过的 bitcode 去生成。</div><div class="line">![](media/14948385529165/14963045212932.jpg)</div><div class="line"></div><div class="line">**生成目标文件（Assemble）**：生成Target相关Object(Mach-o)</div><div class="line">**链接（Link）**：生成 Executable 可执行文件</div><div class="line"></div><div class="line">经过这一步步，我们用各种高级语言编写的代码就转换成了机器可以看懂可以执行的目标代码了。</div><div class="line"></div><div class="line">-------------------</div><div class="line">环境搭建</div></pre></td></tr></table></figure></p>
<p>cd /opt<br>sudo mkdir llvm<br>sudo chown <code>whoami</code> llvm<br>cd llvm<br>export LLVM_HOME=<code>pwd</code></p>
<p>git clone -b release_39 git@github.com:llvm-mirror/llvm.git llvm<br>git clone -b release_39 git@github.com:llvm-mirror/clang.git llvm/tools/clang<br>git clone -b release_39 git@github.com:llvm-mirror/clang-tools-extra.git llvm/tools/clang/tools/extra<br>git clone -b release_39 git@github.com:llvm-mirror/compiler-rt.git llvm/projects/compiler-rt</p>
<p>mkdir llvm_build<br>cd llvm_build<br>cmake ../llvm -DCMAKE_BUILD_TYPE:STRING=Release<br>make -j<code>sysctl -n hw.logicalcpu</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">文件很多很大，需要下载一段时间</div><div class="line"></div><div class="line"></div><div class="line">-------------------</div><div class="line"></div><div class="line">###Clang Static Analyzer静态代码分析</div><div class="line"></div><div class="line">clang 静态分析是通过建立分析引擎和 checkers 所组成的架构，这部分功能可以通过 clang —analyze 命令方式调用。</div><div class="line"></div><div class="line"></div><div class="line">####命令行执行</div><div class="line">通过``clang -cc1 -analyzer-checker-help``可以列出能调用的 checker，但这些checker并不是所有都是默认开启的</div></pre></td></tr></table></figure>
<p>这里使用一个默认关闭的checker-alpha.security.ArrayBoundV2作为例子进行操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<p>$ clang -cc1 -analyzer-checker-help<br> alpha.core.BoolAssignment       Warn about assigning non-{0,1} values to Boolean variables<br>  alpha.core.CastSize             Check when casting a malloced type T, whether the size is a multiple of the size of T<br>  alpha.core.CastToStruct         Check for cast from non-struct pointer to struct pointer<br>  alpha.core.FixedAddr            Check for assignment of a fixed address to a pointer<br>  alpha.core.IdenticalExpr        Warn about unintended use of identical expressions in operators<br>  alpha.core.PointerArithm        Check for pointer arithmetic on locations other than array elements<br>  alpha.core.PointerSub           Check for pointer subtractions on two pointers pointing to different memory chunks<br>  alpha.core.SizeofPtr            Warn about unintended use of sizeof() on pointer expressions<br>  alpha.cplusplus.NewDeleteLeaks  Check for memory leaks. Traces memory managed by new/delete.<br>  alpha.cplusplus.VirtualCall     Check virtual function calls during construction or destruction<br>  …<br>  alpha.security.ArrayBound       Warn about buffer overflows (older checker)<br>  alpha.security.ArrayBoundV2     Warn about buffer overflows (newer checker)<br>  alpha.security.MallocOverflow   Check for overflows in the arguments to malloc()<br>  alpha.security.ReturnPtrRange   Check for an out-of-bound pointer being returned to callers<br>  …<br>  core.CallAndMessage             Check for logical errors for function calls and Objective-C message expressions (e.g., uninitialized arguments, null function pointers)<br>  core.DivideZero                 Check for division by zero<br>  core.DynamicTypePropagation     Generate dynamic type information<br>  core.NonNullParamChecker        Check for null pointers passed as arguments to a function whose arguments are references or marked with the ‘nonnull’ attribute<br>  core.NullDereference            Check for dereferences of null pointers<br>  core.StackAddressEscape         Check that addresses to stack memory do not escape the function<br>  …<br>  unix.API                        Check calls to various UNIX/Posix functions<br>  unix.Malloc                     Check for memory leaks, double free, and use-after-free problems. Traces memory managed by malloc()/free().<br>  unix.MallocSizeof               Check for dubious malloc arguments involving sizeof<br>  unix.MismatchedDeallocator      Check for mismatched deallocators.<br>  unix.cstring.BadSizeArg         Check the size argument passed into C string functions for common erroneous patterns<br>  unix.cstring.NullArg            Check for null pointers being passed as arguments to C string functions</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">可以使用 -enable-checker 和 -disable-checker 开启和禁用具体的 checker 或者 某种类别的 checker。</div></pre></td></tr></table></figure>
<p>$ scan-build -enable-checker alpha.security.ArrayBoundV2 … # 启用数组边界检查<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">当然，使用``scan-build``启用的``checker``只适用于使用``scan-build``生成的html报告。</div><div class="line">``scan-build``在编译安装 llvm/clang 之后可以在``/llvm/tools/clang/tools/scan-build``目录下找到</div></pre></td></tr></table></figure></p>
<p>//允许未被默认允许的check并进行代码分析并将输出结果输出至网页<br>./scan-build  -enable-checker alpha.security.ArrayBoundV2 –use-analyzer=/opt/llvm/llvm_build/bin -V xcodebuild  -project /Users/yuhao/TestClang/TestClang.xcodeproj -sdk iphonesimulator10.3<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">我们在TestClang.xcodeproj的main.m文件中插入一段**数组越界**的代码</div></pre></td></tr></table></figure></p>
<p>int main(){<br>    @autoreleasepool {<br>        int a[2];<br>        int i;<br>        for (i = 0; i &lt; 3; i++){<br>            a[i] = 0;<br>        }<br>    }<br>    return 0;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">然后执行上面的命令，会导出这样的一个界面</div><div class="line">![](media/14948385529165/14963820296360.jpg)</div><div class="line"></div><div class="line">查看报表</div><div class="line">![](media/14948385529165/14963824164565.jpg)</div><div class="line"></div><div class="line">报表中提示了该代码有数组越界的问题。</div><div class="line"></div><div class="line">####Xcode执行</div><div class="line">Xcode本身已经自带了静态检测的功能，可以通过Product-Analyze来执行静态检测，这也只是用自带的clang去执行，如果想用其他的版本，比如自己编译clang，就需要通过命令来设置。</div><div class="line">![](media/14948385529165/14963053341130.jpg)</div><div class="line">在Xcode的Product选项卡下有Analyze的选项，Xcode中默认提供了一些checkers。</div></pre></td></tr></table></figure>
<p>Usage: set-xcode-analyzer [options]</p>
<p>Options:<br>  -h, –help            show this help message and exit<br>  –use-checker-build=PATH<br>                        Use the Clang located at the provided absolute path,<br>                        e.g. /Users/foo/checker-1<br>  –use-xcode-clang     Use the Clang bundled with Xcode</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">可以看到，它有2个选项，</div><div class="line"></div><div class="line">```--use-checker-build```：用于将xcode的clang版本切换成设定的版本</div><div class="line">```--use-xcode-clang```：用于将xcode的clang版本切换回去</div><div class="line"></div><div class="line">注：在执行上面命令的时候，需要退出xcode执行；且需要用sudo的方式运行。</div><div class="line"></div><div class="line">依然使用上面的project文件，在Build Settings添加参数，如图![](media/14948385529165/14963853867818.jpg)</div></pre></td></tr></table></figure>
<p>-Xanalyzer -analyzer-checker=alpha.security.ArrayBoundV2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">然后cmd+shift+b</div><div class="line">![](media/14948385529165/14963856774140.jpg)</div><div class="line">在Xcode中也出现了和报表同样的提示。</div><div class="line">关于checker的开发可以看[这里](http://clang-analyzer.llvm.org.cn/checker_dev_manual.html)。</div><div class="line"></div><div class="line">--------------</div><div class="line">###关于ARC（AUTOMATIC REFERENCE COUNTING）</div><div class="line"></div><div class="line">ARC是ios5.0引入的新特性，完全消除手动管理内存的繁琐，编译器会自动在适合的代码里面插入适当的retain，release，autorelease的语句。我们不要再担心内存管理，因为编译器帮我们做了这一切。</div><div class="line">我们都知道ARC的规则就是只要对象没有强指针引用，就会被释放掉。那么，该对象是什么时候被释放，又是谁操作去释放该对象的？</div><div class="line"></div><div class="line">**自动添加release**</div></pre></td></tr></table></figure></p>
<p>int main(int argc, const char * argv[]) {<br>    id a;<br>    return 0;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">上面的代码中有强引用的对象，通过以下命令将代码编译成中间语言：</div></pre></td></tr></table></figure></p>
<p>clang -S -fobjc-arc -emit-llvm main.m -o main.ll<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">结果如下：</div></pre></td></tr></table></figure></p>
<p>define i32 @main(i32, i8<strong>) #0 {<br>  %3 = alloca i32, align 4<br>  %4 = alloca i32, align 4<br>  %5 = alloca i8</strong>, align 8<br>  %6 = alloca i8<em>, align 8<br>  store i32 0, i32</em> %3, align 4<br>  store i32 %0, i32<em> %4, align 4<br>  store i8<strong> %1, i8</strong></em> %5, align 8<br>  store i8<em> null, i8** %6, align 8<br>  store i32 0, i32</em> %3, align 4<br>  call void @objc_storeStrong(i8<em>* %6, i8</em> null) #1<br>  %7 = load i32, i32* %3, align 4<br>  ret i32 %7<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alloca函数申请内存地址，而store表示将值存到指定地址。 函数的最后调用了函数`objc_storeStrong`,查询[ARC文档](https://clang.llvm.org/docs/AutomaticReferenceCounting.html#purpose)可以知道`objc_storeStrong`的实现。</div></pre></td></tr></table></figure></p>
<p>void objc_storeStrong(id <em>object, id value) {<br>  id oldValue = </em>object;<br>  value = [value retain];<br>  *object = value;<br>  [oldValue release];<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">`call void @objc_storeStrong(i8** %6, i8* null)`对`null`进行了`retain`，对`a`进行了`release`。</div><div class="line">综上，在`__strong`类型的变量的作用域结束时，自动添加`release`函数进行释放。</div><div class="line"></div><div class="line">**自动添加retain**</div><div class="line">查阅[ARC文档](https://clang.llvm.org/docs/AutomaticReferenceCounting.html#purpose)，发现有`objc_retain`这样一个函数，顾名思义，该函数就是将对象进行`retain`操作。</div></pre></td></tr></table></figure></p>
<p>id objc_retainAutorelease(id value) {<br>  return objc_autorelease(objc_retain(value));<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">`objc_retainAutorelease(id value)`当`value`为`null`或指针指向有效对象,如果`value`为`null`，则此调用不起作用。否则，它执行保留操作，然后执行自动释放操作。即对一个变量先进行一次`retain`，再添进行`autorelease`。</div><div class="line"></div><div class="line">**weak的实现**</div><div class="line">`runtime`是如何实现在`weak`修饰的变量的对象在被销毁时自动置为`nil`的呢？一个普遍的解释是:`runtime`对注册的类会进行布局，对于`weak`修饰的对象会放入一个`hash`表中。用`weak`指向的对象内存地址作为`key`，当此对象的引用计数为`0`的时候会`dealloc`，假如`weak`指向的对象内存地址是`a`，那么就会以`a`为键在这个`weak`表中搜索，找到所有以`a`为键的`weak`对象，从而设置为`nil`。</div><div class="line"></div><div class="line">`weak`指针的实现借助`Objective-C`的运行时特性，`runtime`通过 `objc_storeWeak`, `objc_destroyWeak`和 `objc_moveWeak`等方法，直接修改`__weak`对象，来实现弱引用。</div><div class="line"></div><div class="line">`objc_storeWeak`函数，将附有`__weak`标识符的变量的地址注册到`weak`表中，`weak`表是一份与引用计数表相似的散列表。</div><div class="line"></div><div class="line">而该变量会在释放的过程中清理`weak`表中的引用，变量释放调用以下函数：</div></pre></td></tr></table></figure></p>
<p>dealloc<br>_objec_rootDealloc<br>object_dispose<br>objc_destructInstance<br>objc_clear_deallocating<br><code>``
在最后的</code>objc_clear_deallocating<code>函数中，从</code>weak<code>表中找到弱引用指针的地址，然后置为</code>nil<code>,并从</code>weak`表删除记录。</p>
<p>关于ARC更多实现请参阅<a href="http://luoxianming.cn/2017/05/06/arc/" target="_blank" rel="external">探究ARC</a></p>

  </section>

</article>
<section class="read-more">
           
    
               
            <div class="read-more-item">
                <span class="read-more-item-dim">最近的文章</span>
                <h2 class="post-list__post-title post-title"><a href="/2017/08/03/集成O-LLVM/" title=""></a></h2>
                <p class="excerpt">
                
                Xcode集成O-LLVM要在Xcode中使用O-LLVM，必须要编写一个Xcode插件。
首先
12345$ cd /Applications/Xcode.app/Contents/PlugIns/Xcode3Core.ideplugin/Contents/SharedSupport/Develo
                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2017-08-03T09:05:32.000Z" class="post-list__meta--date date">2017-08-03</time> &#8226; <span class="post-list__meta--tags tags">于&nbsp;</span><a class="btn-border-small" href="/2017/08/03/集成O-LLVM/">继续阅读</a></div>
                           
            </div>
        
        
               
            <div class="read-more-item">
                <span class="read-more-item-dim">更早的文章</span>
                <h2 class="post-list__post-title post-title"><a href="/2017/02/18/FirstNight/" title=""></a></h2>
                <p class="excerpt">
                
                
 title: First Night
我有一头小毛驴，可是我从来都不骑。


                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2017-02-18T08:19:21.000Z" class="post-list__meta--date date">2017-02-18</time> &#8226; <span class="post-list__meta--tags tags">于&nbsp;</span><a class="btn-border-small" href="/2017/02/18/FirstNight/">继续阅读</a></div>
                       
            </div>
        
     
   
   
  
</section>

            
<section class="post-comments">
<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="http://yoursite.com/2017/05/15/LLVM与Clang的一些事儿/" data-title="" data-url="http://yoursite.com/2017/05/15/LLVM与Clang的一些事儿/"></div>
  <!-- 多说评论框 end -->
  <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
  <script type="text/javascript">
  var duoshuoQuery = {short_name:"sthyuhao"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->

</section>


            <footer class="footer">
    <span class="footer__copyright">
        本站点采用 <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>
    </span>
    <span class="footer__copyright">
        基于 <a href="http://hexo.io">Hexo</a> 搭建，感谢 <a href="https://pages.github.com/">GitHub Pages</a> 提供免费的托管服务
    </span>
    <span class="footer__copyright">
        &copy; 2018 - 本站由 <a href="/">@Monniya</a> 创建,
        使用 <a href="https://github.com/monniya/hexo-theme-new-vno ">hexo-theme-new-vno</a> 主题,
        修改自 <a href="https://github.com/lenbo-ma/hexo-theme-vno" target="_blank">Vno</a>, 原创出自<a href="http://github.com/onevcat/vno" target="_blank">onevcat</a>
    </span>
</footer>
        </div>
    </div>

    

     
<script>
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	ga('create', 'UA-78918255-1', 'auto');
	ga('send', 'pageview');
</script>

    
    <script>
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?9cdad07c755fa23f6aced510c6760e87";
            var s = document.getElementsByTagName("script")[0]; 
            s.parentNode.insertBefore(hm, s);
        })();
    </script>



    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
    
    </script>
    
</body>
</html>
